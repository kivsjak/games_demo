<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ants vs Plants - Towers Mode</title>
    <style>
        :root {
            --primary: #fbbf24; /* Brighter Amber */
            --primary-dark: #b45309;
            --bg-dark: #1c1917;
            --panel-bg: #292524;
            --text-light: #e7e5e4;
            --accent-green: #4ade80; /* Neon Green */
            --accent-red: #f87171;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #0c0a09;
            background: linear-gradient(180deg, #1a100c 0%, #000000 100%);
            color: var(--text-light);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .game-wrapper {
            position: relative;
            width: 100%;
            max-width: 1200px;
            height: 100vh;
            max-height: 900px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 50px rgba(0,0,0,0.9);
            border-radius: 12px;
            overflow: hidden;
            background: #2a2018;
            border: 4px solid #78350f;
        }

        /* --- INFO BAR --- */
        .info-bar {
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.9);
            border-bottom: 3px solid #78350f;
            z-index: 10;
        }

        .info-item {
            text-align: center;
            min-width: 80px;
        }

        .info-label {
            color: #9ca3af;
            font-size: 0.75rem;
            text-transform: uppercase;
            margin-bottom: 2px;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .info-value {
            color: var(--primary);
            font-size: 1.2rem;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.4);
        }

        /* --- MULTIPLIER ROW --- */
        .multiplier-row {
            display: flex;
            gap: 6px;
            justify-content: center;
            padding: 12px;
            background: #271c19;
            border-bottom: 3px solid #78350f;
            z-index: 9;
            overflow-x: auto;
        }

        .mult-item {
            padding: 6px 12px;
            background: #44403c;
            border: 2px solid #57534e;
            border-radius: 6px;
            color: #a8a29e;
            font-weight: 800;
            font-size: 0.95rem;
            min-width: 55px;
            text-align: center;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .mult-item.active {
            background: #0284c7;
            border-color: #38bdf8;
            color: #fff;
            transform: scale(1.15) translateY(-2px);
            box-shadow: 0 4px 15px rgba(14, 165, 233, 0.5);
            z-index: 2;
        }

        .mult-item.winning {
            background: #15803d;
            border-color: #4ade80;
            color: #fff;
        }

        /* --- CANVAS AREA --- */
        .canvas-container {
            flex: 1;
            position: relative;
            background-color: #2b1d1a; /* Darker, cooler brown base */
            /* Cleaner vignette: Deep brown/black instead of muddy gray-black */
            background-image: 
                radial-gradient(circle at 50% 50%, rgba(40, 30, 20, 0) 0%, rgba(10, 5, 0, 0.8) 100%),
                url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.7' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.15'/%3E%3C/svg%3E");
            
            cursor: none;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 1;
        }

        .crosshair {
            position: absolute;
            width: 44px;
            height: 44px;
            pointer-events: none;
            z-index: 100;
            transform: translate(-50%, -50%);
            display: none;
            border: 3px solid rgba(173, 255, 47, 0.8); 
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(173, 255, 47, 0.6);
            transition: transform 0.05s; /* Faster for snap */
        }

        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: #ccff00;
            box-shadow: 0 0 8px #ccff00;
        }
        .crosshair::before { top: 19px; left: 6px; width: 32px; height: 3px; }
        .crosshair::after { left: 19px; top: 6px; height: 32px; width: 3px; }
        
        /* New Crosshair Label - STYLED TO MATCH UI */
        .crosshair-label {
            position: absolute;
            top: 48px; /* Below crosshair */
            left: 50%;
            transform: translateX(-50%);
            
            color: var(--primary);
            background: rgba(12, 10, 9, 0.95); /* Deep dark background */
            border: 1px solid var(--primary-dark);
            padding: 4px 10px;
            border-radius: 8px;
            
            font-size: 0.85rem;
            font-weight: 800;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.6);
            
            white-space: nowrap;
            z-index: 102;
            pointer-events: none;
        }

        .current-mult-float {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.85);
            border: 2px solid var(--primary);
            padding: 8px 20px;
            border-radius: 30px;
            font-size: 1.8rem;
            color: var(--primary);
            font-weight: 900;
            display: none;
            z-index: 50;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        /* --- CONTROLS BAR --- */
        .controls {
            background: linear-gradient(135deg, #1c1917 0%, #0c0a09 100%);
            padding: 20px;
            border-top: 4px solid #78350f;
            display: grid;
            grid-template-columns: 1fr 1.5fr 1fr;
            gap: 25px;
            align-items: center;
            position: relative;
            z-index: 20;
            box-shadow: 0 -10px 30px rgba(0,0,0,0.5);
        }

        @media (max-width: 768px) {
            .controls { grid-template-columns: 1fr; padding: 15px; }
        }

        /* Bet Section */
        .control-col { display: flex; flex-direction: column; gap: 10px; }
        .label { color: var(--primary); font-size: 0.85rem; font-weight: 800; text-transform: uppercase; letter-spacing: 1px; }

        .bet-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            background: #000;
            padding: 8px;
            border-radius: 8px;
            border: 2px solid #4b5563;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
        }

        .bet-input-group input {
            background: transparent;
            border: none;
            color: #fff;
            font-size: 1.4rem;
            font-weight: 900;
            width: 100%;
            text-align: center;
            outline: none;
        }

        .quick-buttons { display: flex; gap: 6px; justify-content: center; }
        
        .quick-btn {
            padding: 8px 12px;
            background: linear-gradient(to bottom, #57534e, #292524);
            border: 1px solid #1c1917;
            border-radius: 6px;
            color: #e5e7eb;
            font-weight: 800;
            font-size: 0.75rem;
            cursor: pointer;
            flex: 1;
            box-shadow: 0 2px 0 #1c1917;
            transition: all 0.1s;
        }
        .quick-btn:hover:not(:disabled) { background: #78716c; transform: translateY(-1px); }
        .quick-btn:active:not(:disabled) { transform: translateY(2px); box-shadow: none; }
        .quick-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        /* Difficulty Section */
        .difficulty-buttons {
            display: flex;
            gap: 6px;
            background: #1a1512;
            padding: 6px;
            border-radius: 10px;
            border: 1px solid #444;
        }

        .difficulty-btn {
            flex: 1;
            padding: 12px 5px;
            background: transparent;
            border: 1px solid transparent;
            color: #9ca3af;
            font-weight: 800;
            font-size: 0.8rem;
            cursor: pointer;
            border-radius: 6px;
            text-transform: uppercase;
            transition: 0.2s;
        }

        .difficulty-btn.active {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border: 1px solid #34d399;
            box-shadow: 0 4px 10px rgba(16, 185, 129, 0.4);
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .difficulty-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Play Button */
        .play-button {
            width: 100%;
            height: 70px;
            background: linear-gradient(135deg, #0ea5e9, #0369a1);
            border: 2px solid #38bdf8;
            border-bottom-width: 6px;
            border-radius: 12px;
            color: white;
            font-size: 1.8rem;
            font-weight: 900;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(14, 165, 233, 0.4);
            transition: all 0.1s;
            text-shadow: 0 2px 0 rgba(0,0,0,0.3);
            letter-spacing: 1px;
        }
        
        .play-button:active:not(:disabled) {
            transform: translateY(4px);
            border-bottom-width: 2px;
            box-shadow: none;
        }
        
        .play-button.cashout {
            background: linear-gradient(135deg, #22c55e, #15803d);
            border-color: #86efac;
            box-shadow: 0 5px 15px rgba(34, 197, 94, 0.4);
        }

        .play-button:disabled {
            background: #4b5563;
            border-color: #6b7280;
            box-shadow: none;
            cursor: not-allowed;
            transform: none;
            border-bottom-width: 2px;
        }

        /* Status Overlay */
        .status-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            display: none;
        }
        
        .status-content {
            background: #1c1917;
            border: 4px solid var(--primary);
            padding: 50px;
            border-radius: 20px;
            text-align: center;
            animation: zoomIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        @keyframes zoomIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        .status-title { font-size: 3rem; margin-bottom: 15px; text-transform: uppercase; font-weight: 900; letter-spacing: 2px; }
        .status-text { font-size: 1.4rem; color: #d1d5db; margin-bottom: 30px; }
        .status-btn {
            padding: 15px 40px;
            background: var(--primary);
            color: #000;
            border: 2px solid #fcd34d;
            font-weight: 900;
            font-size: 1.1rem;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 4px 0 #b45309;
            transition: all 0.1s;
        }
        .status-btn:active { transform: translateY(4px); box-shadow: none; }
        .status-btn:hover { background: #fbbf24; filter: brightness(1.1); }

        .text-win { color: #4ade80; text-shadow: 0 0 20px rgba(74, 222, 128, 0.6); }
        .text-loss { color: #f87171; text-shadow: 0 0 20px rgba(248, 113, 113, 0.6); }

    </style>
</head>
<body>

<div class="game-wrapper">
    <!-- Info Bar -->
    <div class="info-bar">
        <div class="info-item">
            <div class="info-label">БАЛАНС</div>
            <div class="info-value" id="balance">$1000.00</div>
        </div>
        <div class="info-item">
            <div class="info-label">ЗАГРОЗА</div>
            <div class="info-value" id="danger-level">50%</div>
        </div>
        <div class="info-item">
            <div class="info-label">РІВЕНЬ</div>
            <div class="info-value" id="level">1</div>
        </div>
        <div class="info-item">
            <div class="info-label">ВЛУЧАНЬ</div>
            <div class="info-value" id="hits">0</div>
        </div>
    </div>

    <!-- Multiplier Row -->
    <div class="multiplier-row" id="multiplier-row">
        <!-- JS Generated -->
    </div>

    <!-- Canvas -->
    <div class="canvas-container" id="canvas-container">
        <canvas id="gameCanvas"></canvas>
        <div class="crosshair" id="crosshair">
            <div class="crosshair-label" id="crosshair-mult">x1.0</div>
        </div>
        <div class="current-mult-float" id="float-mult">x1.00</div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <!-- Bet Amount -->
        <div class="control-col">
            <div class="label">СТАВКА</div>
            <div class="bet-input-group">
                <span style="color:var(--primary); font-weight:bold; margin-left:5px;">$</span>
                <input type="number" id="bet-input" value="10.00" step="0.01">
            </div>
            <div class="quick-buttons">
                <button class="quick-btn" id="btn-half">1/2</button>
                <button class="quick-btn" id="btn-double">2X</button>
                <button class="quick-btn" id="btn-minus">-</button>
                <button class="quick-btn" id="btn-plus">+</button>
            </div>
        </div>

        <!-- Difficulty -->
        <div class="control-col">
            <div class="label" style="text-align:center;">СКЛАДНІСТЬ</div>
            <div class="difficulty-buttons" id="diff-container">
                <button class="difficulty-btn" data-diff="easy">Easy</button>
                <button class="difficulty-btn active" data-diff="medium">Medium</button>
                <button class="difficulty-btn" data-diff="hard">Hard</button>
                <button class="difficulty-btn" data-diff="expert">Expert</button>
                <button class="difficulty-btn" data-diff="crazy">Crazy</button>
            </div>
        </div>

        <!-- Play Button -->
        <div class="control-col">
            <button class="play-button" id="play-btn">PLAY</button>
        </div>
    </div>

    <!-- Overlay -->
    <div class="status-overlay" id="overlay">
        <div class="status-content">
            <h2 class="status-title" id="overlay-title">ВЕЛИКИЙ ВИГРАШ</h2>
            <p class="status-text" id="overlay-text">Рослину відкинуто!</p>
            <div style="display:flex; gap:15px; justify-content:center;">
                <button class="status-btn" id="overlay-btn-1">Далі</button>
                <button class="status-btn" id="overlay-btn-2" style="background:#4b5563; border-color:#6b7280; color:white;">Залишитись</button>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * --- CONFIGURATION & CONSTANTS ---
 */
const CONFIG = {
    // Math / Logic Parameters
    SegmentsCount: 7, 
    StartProgress: 0.5, 
    SegmentProgressStep: 0.08, 
    
    // Penalties & Steps
    AdvanceStep: 1, 
    AdvanceOnCashout: 0.25, 
    LosePoint: 0.95, 

    // Visuals
    HeadSpacing: 40, 
    GroupGap: 100, 
    CompressedSpacing: 8, 
    CompressedGroupGap: 15, 
    ZigZagOffset: 25, 
    LerpSpeed: 0.1, // Controls smoothness of vine movement
    
    // Auto-aim
    SnapDistance: 60, // Distance in pixels to snap to head
    
    BET_SEQUENCE: [
        0.01, 0.02, 0.05, 0.10, 0.20, 0.50,
        1.00, 2.00, 5.00, 10.00, 20.00, 50.00,
        100.00, 200.00, 500.00, 1000.00, 2000.00, 5000.00
    ],

    DIFFICULTIES: {
        easy: { label: 'Easy', probability: 0.75, multipliers: [1.1, 1.2, 1.4, 1.6, 2.0, 2.5, 3.2, 4.0, 5.0, 7.0, 10.0] },
        medium: { label: 'Medium', probability: 0.667, multipliers: [1.2, 1.4, 1.7, 2.1, 2.6, 3.4, 4.5, 6.0, 8.0, 12.0, 18.0] },
        hard: { label: 'Hard', probability: 0.50, multipliers: [1.3, 1.6, 2.0, 2.6, 3.5, 4.8, 6.5, 9.0, 13.0, 20.0, 30.0] },
        expert: { label: 'Expert', probability: 0.333, multipliers: [1.5, 2.0, 2.8, 4.0, 6.0, 9.0, 14.0, 22.0, 35.0, 55.0, 90.0] },
        crazy: { label: 'Crazy', probability: 0.25, multipliers: [1.8, 2.5, 4.0, 6.5, 11.0, 18.0, 30.0, 50.0, 85.0, 150.0, 250.0] }
    }
};

/**
 * --- GAME STATE ---
 */
const gameState = {
    balance: 1000.00,
    vineProgress: 0.5, 
    plantPosition: 0, 
    
    currentLevel: 1,
    betAmount: 10.00,
    difficulty: 'medium',

    roundActive: false,
    consecutiveHits: 0,
    
    uiLocked: false,
    mouseX: 0,
    mouseY: 0,
    
    aimX: 0, // Actual aiming coordinates (with snap)
    aimY: 0,
    snappedTarget: null, // If we are locked onto a head
    
    path: [],
    projectiles: [],
    particles: [],
    floatingTexts: [],
    
    // The Vine Data
    heads: [], 
    segments: [], 
    activeSegmentIndex: 0,
    
    totalVineLength: 0,
    visualVineLength: 0 // For smoothing
};

/**
 * --- CANVAS SETUP ---
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvas-container');

function resize() {
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    generatePath();
}
window.addEventListener('resize', resize);

/**
 * --- PATH & VINE GENERATION ---
 */
function generatePath() {
    const w = canvas.width;
    const h = canvas.height;
    gameState.path = [];

    const points = [
        {x: 0, y: 50},
        {x: w * 0.9, y: 50},
        {x: w * 0.9, y: h * 0.4},
        {x: w * 0.1, y: h * 0.45},
        {x: w * 0.1, y: h * 0.85},
        {x: w * 0.8, y: h * 0.85},
        {x: w - 50, y: h - 50}
    ];
    
    for (let i = 0; i < points.length - 1; i++) {
        const p0 = points[i];
        const p1 = points[i+1];
        const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);
        const steps = Math.floor(dist); 
        
        for (let j = 0; j < steps; j++) {
            const t = j / steps;
            gameState.path.push({
                x: p0.x + (p1.x - p0.x) * t,
                y: p0.y + (p1.y - p0.y) * t
            });
        }
    }
}

function generateVineHeads() {
    gameState.heads = [];
    gameState.segments = [];
    
    // Color cycle: Red -> Blue -> Yellow -> Purple
    const colors = ['#ef4444', '#3b82f6', '#eab308', '#a855f7'];
    
    // Create segments
    for (let g = 0; g < CONFIG.SegmentsCount; g++) {
        const color = colors[g % colors.length];
        const segmentHeads = [];
        
        // 4 Heads per segment
        for (let h = 0; h < 4; h++) {
            const headObj = {
                offset: 0, // Target Logical Offset
                visualOffset: 0, // Current Visual Offset (for lerp)
                side: (h % 2 === 0) ? -1 : 1,
                groupIndex: g,
                id: g * 4 + h
            };
            
            gameState.heads.push(headObj);
            segmentHeads.push(headObj);
        }
        
        gameState.segments.push({
            index: g,
            color: color,
            heads: segmentHeads,
            compressed: false
        });
    }
    
    // Initial Layout - Instant
    updateVineLayout(true);
}

/**
 * UPDATE VINE LAYOUT
 */
function updateVineLayout(instant = false) {
    let currentDist = 0;
    
    for (let g = 0; g < gameState.segments.length; g++) {
        const seg = gameState.segments[g];
        const spacing = seg.compressed ? CONFIG.CompressedSpacing : CONFIG.HeadSpacing;
        const gap = seg.compressed ? CONFIG.CompressedGroupGap : CONFIG.GroupGap;
        
        for (let h = 0; h < seg.heads.length; h++) {
            currentDist += spacing;
            seg.heads[h].offset = currentDist;
            if (instant) seg.heads[h].visualOffset = currentDist;
        }
        currentDist += gap;
    }
    
    gameState.totalVineLength = currentDist;
    if (instant) gameState.visualVineLength = currentDist;
    updateVisualProgress();
}

/**
 * Converts Logical PlantPosition to Visual VineProgress
 */
function updateVisualProgress() {
    // 1. Calculate target progress based on logic
    let targetP = CONFIG.StartProgress + (gameState.plantPosition * CONFIG.SegmentProgressStep);
    
    // 2. Safety Clamp: Ensure active segment is visible
    if (gameState.path.length > 0) {
        const activeSeg = gameState.segments[gameState.activeSegmentIndex];
        if (activeSeg) {
             let maxOffset = 0;
             activeSeg.heads.forEach(h => maxOffset = Math.max(maxOffset, h.offset));
             
             // Ensure at least some distance from start so heads are on screen
             const minProgress = (maxOffset + 150) / gameState.path.length; 
             
             if (targetP < minProgress) {
                 targetP = minProgress;
             }
        }
    }
    
    gameState.vineProgress = targetP;
}

/**
 * --- GAME LOGIC ---
 */

function initGame() {
    loadState();
    resize();
    generateVineHeads();
    updateUI();
    generateMultipliers();
    setupInputs();
    requestAnimationFrame(gameLoop);
}

function loadState() {
    const saved = localStorage.getItem('antsVsPlants_state');
    if (saved) {
        const data = JSON.parse(saved);
        gameState.balance = data.balance ?? 1000;
        gameState.currentLevel = data.currentLevel ?? 1;
        gameState.betAmount = data.betAmount ?? 10;
        gameState.difficulty = data.difficulty ?? 'medium';
    }
    document.getElementById('bet-input').value = gameState.betAmount.toFixed(2);
    document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.diff === gameState.difficulty);
    });
}

function saveState() {
    localStorage.setItem('antsVsPlants_state', JSON.stringify({
        balance: gameState.balance,
        currentLevel: gameState.currentLevel,
        betAmount: gameState.betAmount,
        difficulty: gameState.difficulty
    }));
}

function startRound() {
    if (gameState.betAmount > gameState.balance) {
        alert("Недостатньо коштів!");
        return;
    }
    
    gameState.balance -= gameState.betAmount;
    gameState.roundActive = true;
    gameState.consecutiveHits = 0;
    gameState.uiLocked = true;
    
    // Reset Logic
    gameState.activeSegmentIndex = 0;
    gameState.segments.forEach(s => s.compressed = false);
    
    // NEW LOGIC: Position Reset based on Threat
    // Якщо ліана в безпечній зоні (pushed back), скидаємо на центр (0).
    // Якщо ліана в небезпечній зоні (pushed forward), залишаємо як є.
    if (gameState.plantPosition < 0) {
        gameState.plantPosition = 0;
    }
    
    updateVineLayout();
    updateUI();
    lockUI(true);
    
    const btn = document.getElementById('play-btn');
    btn.textContent = "CASHOUT";
    btn.classList.add('cashout');
    
    document.getElementById('crosshair').style.display = 'block';
    // Update label
    document.getElementById('crosshair-mult').textContent = "x" + getCurrentMultiplier().toFixed(1);

    document.getElementById('float-mult').style.display = 'block';
    document.getElementById('float-mult').textContent = "x" + getCurrentMultiplier().toFixed(2);
    
    saveState();
}

function endRound() {
    gameState.roundActive = false;
    gameState.uiLocked = false;
    
    updateUI();
    lockUI(false);
    
    const btn = document.getElementById('play-btn');
    btn.textContent = "PLAY";
    btn.classList.remove('cashout');
    
    document.getElementById('crosshair').style.display = 'none';
    document.getElementById('float-mult').style.display = 'none';
    
    saveState();
}

function updateGameLogic() {
    if (gameState.roundActive) {
        // Clamp visual percent for UI
        const disp = Math.max(0, Math.floor(gameState.vineProgress * 100));
        document.getElementById('danger-level').textContent = disp + "%";
        
        // Update Crosshair Label
        document.getElementById('crosshair-mult').textContent = "x" + getCurrentMultiplier().toFixed(1);
    }
    
    // --- LERP ANIMATION FOR SMOOTH VINE MOVEMENT ---
    for (const head of gameState.heads) {
        head.visualOffset += (head.offset - head.visualOffset) * CONFIG.LerpSpeed;
    }
    gameState.visualVineLength += (gameState.totalVineLength - gameState.visualVineLength) * CONFIG.LerpSpeed;

    updateAim();
}

/**
 * Calculates current aim position (Magnetic Snap)
 */
function updateAim() {
    // Default aim is mouse position
    gameState.aimX = gameState.mouseX;
    gameState.aimY = gameState.mouseY;
    gameState.snappedTarget = null;
    
    if (!gameState.roundActive) return;

    const activeSegment = gameState.segments[gameState.activeSegmentIndex];
    if (!activeSegment) return;
    
    const pathLen = gameState.path.length;
    const frontIndex = Math.floor(gameState.vineProgress * pathLen);
    
    let closestDist = CONFIG.SnapDistance;
    let bestHead = null;
    
    // Check active heads for snapping
    for (const head of activeSegment.heads) {
        const headPathIdx = Math.floor(frontIndex - head.visualOffset);
        if (headPathIdx < 0 || headPathIdx >= pathLen) continue;
        
        const p = gameState.path[headPathIdx];
        if (!p) continue;

        // Calculate Head Center in World Space
        const pNext = gameState.path[Math.min(pathLen-1, headPathIdx + 5)];
        const pPrev = gameState.path[Math.max(0, headPathIdx - 5)];
        const angle = Math.atan2(pNext.y - pPrev.y, pNext.x - pPrev.x);
        
        // Rotate local offset (0, zigZag) by angle
        const zigZag = CONFIG.ZigZagOffset * head.side;
        
        // Visual Rotation logic: ctx.rotate(angle) -> ctx.translate(0, zigZag)
        // Math: Rotate (0, zigZag) by angle.
        // x' = x*cos - y*sin = 0 - zigZag*sin(angle)
        // y' = x*sin + y*cos = 0 + zigZag*cos(angle)
        const headWorldX = p.x - Math.sin(angle) * zigZag;
        const headWorldY = p.y + Math.cos(angle) * zigZag;
        
        const dist = Math.hypot(gameState.mouseX - headWorldX, gameState.mouseY - headWorldY);
        
        if (dist < closestDist) {
            closestDist = dist;
            bestHead = {
                x: headWorldX, 
                y: headWorldY, 
                angle: angle,
                side: head.side,
                baseX: p.x,
                baseY: p.y,
                headRef: head
            };
        }
    }
    
    if (bestHead) {
        gameState.aimX = bestHead.x;
        gameState.aimY = bestHead.y;
        gameState.snappedTarget = bestHead;
    }

    // Update Crosshair DOM
    const ch = document.getElementById('crosshair');
    ch.style.left = gameState.aimX + 'px';
    ch.style.top = gameState.aimY + 'px';
    
    // Change style if snapped
    if (gameState.snappedTarget) {
        ch.style.borderColor = '#ff0000';
        ch.style.boxShadow = '0 0 15px rgba(255, 0, 0, 0.8)';
    } else {
        ch.style.borderColor = 'rgba(173, 255, 47, 0.8)';
        ch.style.boxShadow = '0 0 15px rgba(173, 255, 47, 0.6)';
    }
}

function onShoot() {
    if (!gameState.roundActive) return;

    const diff = CONFIG.DIFFICULTIES[gameState.difficulty];
    const isSuccess = Math.random() < diff.probability;
    
    spawnProjectile(isSuccess);
}

function resolveShot(isSuccess) {
    if (isSuccess) {
        // --- HIT LOGIC ---
        const currentSegment = gameState.segments[gameState.activeSegmentIndex];
        if (currentSegment) currentSegment.compressed = true; 
        
        gameState.activeSegmentIndex++;
        
        // RETREAT LOGIC: PUSH BACK ALWAYS
        // Removed Math.max(0, ...) so it pushes back even if at start
        gameState.plantPosition -= CONFIG.AdvanceStep;
        
        gameState.consecutiveHits++;
        
        const lastProj = gameState.projectiles[gameState.projectiles.length-1];
        if (lastProj) spawnFloatingText(lastProj.tx, lastProj.ty, "HIT!", "#4ade80");
        createParticles(true);
        
        if (gameState.activeSegmentIndex >= CONFIG.SegmentsCount) {
            triggerVictory();
        } else {
            document.getElementById('float-mult').textContent = "x" + getCurrentMultiplier().toFixed(2);
        }
        
    } else {
        // --- BLOCK LOGIC ---
        gameState.segments.forEach(seg => seg.compressed = false);
        gameState.activeSegmentIndex = 0;
        gameState.consecutiveHits = 0;
        
        // ADVANCE LOGIC: PENALTY or RESET
        if (gameState.plantPosition < 0) {
            // Was in safe zone -> Reset to start (0) - Lose advantage
            gameState.plantPosition = 0;
        } else {
            // Was at start (0) or danger zone (>0) -> Move forward (Penalty)
            gameState.plantPosition += CONFIG.AdvanceStep;
        }
        
        const lastProj = gameState.projectiles[gameState.projectiles.length-1];
        if (lastProj) spawnFloatingText(lastProj.tx, lastProj.ty, "BLOCKED", "#f87171"); 
        
        createParticles(false);
        endRound();
        
        if (gameState.vineProgress >= CONFIG.LosePoint) {
            triggerDefeat();
        }
    }
    
    updateVineLayout();
    updateUI();
}

function cashout() {
    if (!gameState.roundActive) return;
    
    const mult = getCurrentMultiplier();
    const winnings = gameState.betAmount * mult;
    gameState.balance += winnings;
    
    gameState.plantPosition += CONFIG.AdvanceOnCashout;
    
    gameState.segments.forEach(s => s.compressed = false);
    gameState.activeSegmentIndex = 0;
    
    updateVineLayout();

    if (gameState.vineProgress >= CONFIG.LosePoint) {
        triggerDefeat();
    } else {
        alert(`Cashout! Ви виграли $${winnings.toFixed(2)}`);
        endRound();
    }
}

function triggerVictory() {
    const mult = getCurrentMultiplier();
    const winnings = gameState.betAmount * mult;
    gameState.balance += winnings;
    showOverlay('ВЕЛИКИЙ ВИГРАШ', `Рослину знищено! Виграш $${winnings.toFixed(2)}`, true);
    endRound();
    gameState.plantPosition = 0; // FULL RESET ON VICTORY
    updateVineLayout();
}

function triggerDefeat() {
    showOverlay('ПОРАЗКА', 'Рослина захопила тунель!', false);
    endRound();
    gameState.plantPosition = 0;
    updateVineLayout();
}

function showOverlay(title, text, isWin) {
    const el = document.getElementById('overlay');
    const tEl = document.getElementById('overlay-title');
    const pEl = document.getElementById('overlay-text');
    const b1 = document.getElementById('overlay-btn-1');
    const b2 = document.getElementById('overlay-btn-2');
    
    tEl.textContent = title;
    tEl.className = isWin ? 'status-title text-win' : 'status-title text-loss';
    pEl.textContent = text;
    el.style.display = 'flex';
    
    b1.textContent = isWin ? "Далі" : "Спробувати ще";
    b1.onclick = () => {
        el.style.display = 'none';
        if (isWin) gameState.currentLevel++;
        updateUI();
    };
    
    b2.textContent = isWin ? "Залишитись" : "Вихід";
    b2.onclick = () => {
        el.style.display = 'none';
        updateUI();
    };
}

function getCurrentMultiplier() {
    const diff = CONFIG.DIFFICULTIES[gameState.difficulty];
    if (gameState.consecutiveHits === 0) return 1.0;
    const idx = Math.min(gameState.consecutiveHits - 1, diff.multipliers.length - 1);
    return diff.multipliers[idx];
}

/**
 * --- UI & INPUTS ---
 */
function updateUI() {
    document.getElementById('balance').textContent = `$${gameState.balance.toFixed(2)}`;
    document.getElementById('danger-level').textContent = Math.floor(gameState.vineProgress * 100) + "%";
    document.getElementById('level').textContent = gameState.currentLevel;
    document.getElementById('hits').textContent = gameState.consecutiveHits;
    updateMultiplierRow();
}

function generateMultipliers() {
    const container = document.getElementById('multiplier-row');
    container.innerHTML = '';
    const diff = CONFIG.DIFFICULTIES[gameState.difficulty];
    diff.multipliers.forEach((m, i) => {
        const div = document.createElement('div');
        div.className = 'mult-item';
        div.id = `mult-${i}`;
        div.textContent = `x${m.toFixed(1)}`;
        container.appendChild(div);
    });
}

function updateMultiplierRow() {
    const items = document.querySelectorAll('.mult-item');
    items.forEach((item, i) => {
        item.className = 'mult-item';
        if (i < gameState.consecutiveHits) item.classList.add('winning');
        if (i === gameState.consecutiveHits) item.classList.add('active');
    });
}

function lockUI(locked) {
    document.getElementById('bet-input').disabled = locked;
    document.querySelectorAll('.quick-btn').forEach(b => b.disabled = locked);
    document.querySelectorAll('.difficulty-btn').forEach(b => b.disabled = locked);
}

function setupInputs() {
    document.getElementById('bet-input').addEventListener('change', (e) => {
        let val = parseFloat(e.target.value);
        if (val < 0.01) val = 0.01;
        gameState.betAmount = val;
        saveState();
    });
    document.getElementById('btn-half').onclick = () => setBet(gameState.betAmount / 2);
    document.getElementById('btn-double').onclick = () => setBet(gameState.betAmount * 2);
    document.getElementById('btn-minus').onclick = () => adjustBetSequence(-1);
    document.getElementById('btn-plus').onclick = () => adjustBetSequence(1);

    document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.onclick = () => {
            if (gameState.uiLocked) return;
            gameState.difficulty = btn.dataset.diff;
            document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            generateMultipliers();
            saveState();
        };
    });

    document.getElementById('play-btn').onclick = () => {
        if (gameState.roundActive) cashout();
        else startRound();
    };

    container.addEventListener('mousemove', (e) => {
        const rect = container.getBoundingClientRect();
        gameState.mouseX = e.clientX - rect.left;
        gameState.mouseY = e.clientY - rect.top;
        // Crosshair update is now handled in updateAim() loop for smoothness and snap logic
    });

    container.addEventListener('mousedown', (e) => {
        if (!gameState.roundActive) return;
        if (gameState.projectiles.length > 0) return; 
        
        // Use Aim coordinates (snapped or not)
        const clickX = gameState.aimX;
        const clickY = gameState.aimY;
        
        const pathLen = gameState.path.length;
        const frontIndex = Math.floor(gameState.vineProgress * pathLen);
        
        const activeSegment = gameState.segments[gameState.activeSegmentIndex];
        if (!activeSegment) return;
        
        let clickedHead = false;
        
        // If we are snapped, we definitely clicked a head
        if (gameState.snappedTarget) {
            clickedHead = true;
        } else {
            // Manual fallback loose check (just in case)
             let minDist = 50; 
             for (const head of activeSegment.heads) {
                const headPathIdx = Math.floor(frontIndex - head.visualOffset);
                if (headPathIdx < 0 || headPathIdx >= pathLen) continue;
                const p = gameState.path[headPathIdx];
                if (!p) continue;
                
                // We need to check against actual visual position, which is approximate to p for click detect
                // But better to use the snapped logic. 
                // Since we update Snap every frame, if clickedHead is false here, it means we weren't close enough.
                const zigZag = CONFIG.ZigZagOffset * head.side;
                // Simplified distance check to base path point for non-snapped
                const dist = Math.hypot(clickX - p.x, clickY - p.y);
                 if (dist < minDist) {
                    clickedHead = true;
                }
            }
        }
        
        if (clickedHead) {
            onShoot();
        }
    });
}

function setBet(val) {
    if (gameState.uiLocked) return;
    if (val < 0.01) val = 0.01;
    if (val > 2000000) val = 2000000;
    gameState.betAmount = val;
    document.getElementById('bet-input').value = val.toFixed(2);
    saveState();
}

function adjustBetSequence(dir) {
    const seq = CONFIG.BET_SEQUENCE;
    let neu = gameState.betAmount;
    if (dir > 0) {
        for (let s of seq) if (s > gameState.betAmount + 0.001) { neu = s; break; }
    } else {
        for (let i = seq.length - 1; i >= 0; i--) if (seq[i] < gameState.betAmount - 0.001) { neu = seq[i]; break; }
    }
    setBet(neu);
}

/**
 * --- VISUALS ---
 */
function spawnProjectile(isSuccess) {
    // If we have a snapped target, use its exact coordinates!
    let tx = gameState.aimX;
    let ty = gameState.aimY;
    
    // Fallback if not snapped (shouldn't happen often if aiming works well)
    if (!gameState.snappedTarget) {
         const pathLen = gameState.path.length;
         const progressIndex = Math.floor(gameState.vineProgress * pathLen);
         const activeSegment = gameState.segments[gameState.activeSegmentIndex];
         if (activeSegment && activeSegment.heads.length > 0) {
            const head = activeSegment.heads[0];
            const idx = Math.max(0, Math.floor(progressIndex - head.visualOffset));
            if (gameState.path[idx]) {
                tx = gameState.path[idx].x;
                ty = gameState.path[idx].y;
            }
         }
    }

    const cx = canvas.width / 2;
    const cy = (canvas.height / 2) + 50;

    const mouseAngle = Math.atan2(gameState.aimY - cy, gameState.aimX - cx);
    const barrelLen = 40; 
    const muzzleX = cx + Math.cos(mouseAngle) * barrelLen;
    const muzzleY = cy + Math.sin(mouseAngle) * barrelLen;

    createMuzzleFlash(muzzleX, muzzleY, mouseAngle);

    gameState.projectiles.push({
        x: muzzleX, y: muzzleY,
        tx: tx, ty: ty,
        speed: 25,
        isSuccess: isSuccess,
        life: 100,
        trail: [] 
    });
}

function spawnFloatingText(x, y, text, color = "#fbbf24") {
    gameState.floatingTexts.push({
        x: x, y: y,
        text: text,
        color: color,
        vy: -3,
        life: 1.0
    });
}

function createMuzzleFlash(x, y, angle) {
    for(let i=0; i<12; i++) {
        const spread = (Math.random() - 0.5) * 1.0;
        const speed = 2 + Math.random() * 6;
        gameState.particles.push({
            x: x, y: y,
            vx: Math.cos(angle + spread) * speed,
            vy: Math.sin(angle + spread) * speed,
            color: Math.random() > 0.5 ? '#ccff00' : '#adff2f',
            life: 0.4 + Math.random() * 0.3,
            size: 3 + Math.random() * 4,
            decay: 0.05
        });
    }
    gameState.particles.push({
        x: x, y: y,
        vx: Math.cos(angle)*2, vy: Math.sin(angle)*2,
        color: 'rgba(200, 255, 0, 0.6)',
        life: 0.25,
        size: 20,
        decay: 0.08
    });
}

function createParticles(isWin) {
    const cx = gameState.projectiles[0]?.tx || canvas.width/2;
    const cy = gameState.projectiles[0]?.ty || canvas.height/2;
    
    const count = isWin ? 40 : 20;
    
    for(let i=0; i<count; i++) {
        const speed = 3 + Math.random() * 12;
        const angle = Math.random() * Math.PI * 2;
        
        let color;
        if (isWin) {
            const r = Math.random();
            if (r > 0.6) color = '#ccff00';
            else if (r > 0.3) color = '#22c55e';
            else color = '#ffffff';
        } else {
            color = Math.random() > 0.5 ? '#adff2f' : '#ffffff';
        }

        gameState.particles.push({
            x: cx, y: cy,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            color: color,
            life: 0.6 + Math.random() * 0.6,
            size: 2 + Math.random() * 5,
            decay: 0.03
        });
    }
    
    gameState.particles.push({
        x: cx, y: cy,
        vx: 0, vy: 0,
        color: 'rgba(150, 255, 50, 0.4)',
        life: 0.6,
        size: 15,
        decay: 0.04,
        isShockwave: true,
        growth: 6
    });
}


function drawHoverHighlight() {
    if (!gameState.roundActive) return;
    
    // We only draw if we have a snapped target (Auto-aim)
    if (gameState.snappedTarget) {
        const st = gameState.snappedTarget;
        
        ctx.save();
        // Transform exactly as the head is transformed
        ctx.translate(st.baseX, st.baseY);
        ctx.rotate(st.angle);
        
        const offsetDist = CONFIG.ZigZagOffset * st.side;
        ctx.translate(0, offsetDist);
        
        // Pulse Effect
        const pulse = 1 + Math.sin(Date.now() * 0.015) * 0.1;
        const size = 32; // Matches active head size in drawPiranhaHead
        
        // GLOW EFFECT (Enhanced)
        ctx.shadowBlur = 25; 
        ctx.shadowColor = '#fbbf24'; 
        ctx.globalCompositeOperation = 'screen'; 
        
        ctx.lineWidth = 4;
        ctx.strokeStyle = `rgba(251, 191, 36, ${0.8 + pulse*0.2})`; // Amber
        
        // Shape matches Piranha Head shape roughly
        ctx.beginPath();
        ctx.arc(0, 0, size * pulse, 0.25 * Math.PI, 1.75 * Math.PI); 
        ctx.lineTo(-size*0.4, 0);
        ctx.closePath();
        ctx.stroke();

        // Faint fill for body glow
        ctx.fillStyle = `rgba(251, 191, 36, 0.1)`;
        ctx.fill();
        
        ctx.restore();
    }
}


function gameLoop() {
    updateGameLogic();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    drawTunnel();
    drawVine();
    drawProjectiles();
    drawParticles();
    drawFloatingTexts();
    drawCannon();
    drawHoverHighlight(); 
    
    requestAnimationFrame(gameLoop);
}

function drawTunnel() {
    if (gameState.path.length === 0) return;
    
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    ctx.lineWidth = 100;
    ctx.strokeStyle = '#0f0806';
    ctx.beginPath();
    ctx.moveTo(gameState.path[0].x, gameState.path[0].y);
    for(let p of gameState.path) ctx.lineTo(p.x, p.y);
    ctx.stroke();

    ctx.lineWidth = 80;
    ctx.strokeStyle = '#271c19';
    ctx.beginPath();
    ctx.moveTo(gameState.path[0].x, gameState.path[0].y);
    for(let p of gameState.path) ctx.lineTo(p.x, p.y);
    ctx.stroke();

    ctx.lineWidth = 60;
    ctx.strokeStyle = '#3e2723';
    ctx.beginPath();
    ctx.moveTo(gameState.path[0].x, gameState.path[0].y);
    for(let p of gameState.path) ctx.lineTo(p.x, p.y);
    ctx.stroke();
    
    ctx.lineWidth = 40;
    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
    ctx.stroke();

    const end = gameState.path[gameState.path.length-1];
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(end.x, end.y, 40, 0, Math.PI*2);
    ctx.fill();
    ctx.font = '30px Arial';
    ctx.fillStyle = '#ef4444';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('☠️', end.x, end.y);
    
    const start = gameState.path[0];
    ctx.fillStyle = '#15803d';
    ctx.beginPath();
    ctx.arc(start.x, start.y, 20, 0, Math.PI*2);
    ctx.fill();
}

function drawVine() {
    if (gameState.path.length === 0) return;
    
    const pathLen = gameState.path.length;
    const frontIndex = Math.floor(gameState.vineProgress * pathLen);
    
    if (frontIndex > 0) {
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        ctx.strokeStyle = '#064e3b'; 
        ctx.lineWidth = 14;
        ctx.beginPath();
        
        // ANCHOR THE STEM TO THE START!
        let startIdx = 0; // Always start drawing from root
        let endIdx = frontIndex;
        
        if (gameState.path[Math.floor(startIdx)]) {
             ctx.moveTo(gameState.path[Math.floor(startIdx)].x, gameState.path[Math.floor(startIdx)].y);
        }
        
        for(let i=startIdx; i<=endIdx; i+=4) { 
            const p = gameState.path[Math.floor(i)]; 
            if(p) ctx.lineTo(p.x, p.y); 
        }
        ctx.stroke();

        ctx.strokeStyle = '#15803d'; 
        ctx.lineWidth = 8;
        ctx.stroke();
        
        ctx.strokeStyle = '#4ade80';
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.3;
        ctx.stroke();
        ctx.globalAlpha = 1.0;
    }
    
    // DRAW HEADS 
    for (let i = gameState.heads.length - 1; i >= 0; i--) {
        const head = gameState.heads[i];
        // Use SMOOTH visualOffset
        const headPathIdx = Math.floor(frontIndex - head.visualOffset);
        
        if (headPathIdx < 0) continue;
        
        const p = gameState.path[headPathIdx];
        if (!p) continue;
        
        const pNext = gameState.path[Math.min(pathLen-1, headPathIdx + 5)];
        const pPrev = gameState.path[Math.max(0, headPathIdx - 5)];
        let angle = Math.atan2(pNext.y - pPrev.y, pNext.x - pPrev.x);
        
        const segment = gameState.segments[head.groupIndex];
        const currentColor = segment.color; 
        
        if (segment.compressed) {
            // Wilted look: Randomize offset slightly or angle
            drawCompressedBud(p.x, p.y, angle, currentColor, head.side);
        } else if (head.groupIndex === gameState.activeSegmentIndex) {
            drawPiranhaHead(p.x, p.y, angle, head.side, currentColor, true);
        } else {
            drawPiranhaHead(p.x, p.y, angle, head.side, currentColor, false);
        }
    }
}

function drawCompressedBud(x, y, rotation, color, side) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    
    // Wilted displacement: Move off-center randomly or to the side
    const wiltOffset = side * 15; // Hang to the side
    ctx.translate(0, wiltOffset);
    ctx.rotate(side * 0.5); // Tilt downward/sideways
    
    const size = 8;
    
    ctx.fillStyle = '#4caf50';
    ctx.strokeStyle = '#1b5e20';
    ctx.lineWidth = 1;
    
    for (let i = -1; i <= 1; i+=2) {
        ctx.save();
        ctx.rotate(i * 0.6);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(-size*1.5, size*0.5, -size*2, 0);
        ctx.quadraticCurveTo(-size*1.5, -size*0.5, 0, 0);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
    }

    const grad = ctx.createRadialGradient(-2, -2, 2, 0, 0, size);
    grad.addColorStop(0, color);
    // Cleaner dark
    grad.addColorStop(1, '#0a1a0a'); 
    ctx.fillStyle = grad;
    
    ctx.beginPath();
    ctx.arc(0, 0, size, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.strokeStyle = '#f472b6';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(size*0.5, 0);
    ctx.lineTo(-size*0.2, 0);
    ctx.stroke();
    
    // Draw connection line back to stem if offset is large
    ctx.strokeStyle = '#064e3b';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(0, -wiltOffset);
    ctx.stroke();
    
    ctx.restore();
}

function drawPiranhaHead(x, y, rotation, sideOffset, color, isActive) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    
    const offsetDist = CONFIG.ZigZagOffset * sideOffset;
    ctx.translate(0, offsetDist);
    
    ctx.strokeStyle = '#1b5e20';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(0, -offsetDist); 
    ctx.lineTo(0, 0);
    ctx.stroke();
    
    const size = isActive ? 32 : 22;
    
    ctx.fillStyle = '#4caf50';
    ctx.strokeStyle = '#1b5e20';
    ctx.lineWidth = 1;
    for (let i = -1; i <= 1; i++) {
        ctx.beginPath();
        ctx.rotate(i * 0.5);
        ctx.moveTo(-size*0.3, 0);
        ctx.quadraticCurveTo(-size*0.5, size*0.4, -size*0.8, 0);
        ctx.quadraticCurveTo(-size*0.5, -size*0.4, -size*0.3, 0);
        ctx.fill();
        ctx.stroke();
        ctx.rotate(-i * 0.5);
    }

    const headGrad = ctx.createRadialGradient(-size*0.2, -size*0.2, size*0.1, 0, 0, size);
    
    // FIXED COLORS: Use segment color for ACTIVE state too, but brighter
    if (isActive) {
        headGrad.addColorStop(0, color); 
        // Cleaner dark (deep warm instead of pure black)
        headGrad.addColorStop(1, '#1a0500'); 
    } else {
        headGrad.addColorStop(0, color); 
        // Cleaner dark (deep green instead of gray/black)
        headGrad.addColorStop(1, '#051a05'); 
    }
    ctx.fillStyle = headGrad;

    if (isActive) {
        ctx.beginPath();
        ctx.arc(0, 0, size, 0.25 * Math.PI, 1.75 * Math.PI); 
        ctx.lineTo(-size*0.4, 0);
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = '#f472b6';
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(-size*0.4, 0);
        ctx.lineTo(size * Math.cos(1.75*Math.PI), size * Math.sin(1.75*Math.PI));
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-size*0.4, 0);
        ctx.lineTo(size * Math.cos(0.25*Math.PI), size * Math.sin(0.25*Math.PI));
        ctx.stroke();

        ctx.fillStyle = '#ffffff';
        ctx.beginPath(); ctx.moveTo(size*0.2, -size*0.2); ctx.lineTo(size*0.4, -size*0.6); ctx.lineTo(size*0.6, -size*0.2); ctx.fill();
        ctx.beginPath(); ctx.moveTo(size*0.2, size*0.2); ctx.lineTo(size*0.4, size*0.6); ctx.lineTo(size*0.6, size*0.2); ctx.fill();

    } else {
        ctx.beginPath();
        ctx.arc(0, 0, size, 0, Math.PI*2);
        ctx.fill();
        
        ctx.strokeStyle = '#f472b6';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(size*0.8, 0);
        ctx.lineTo(size*0.2, 0);
        ctx.stroke();
    }
    
    if (color !== '#ef4444' && isActive) {
        // Shine/Spots
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.beginPath();
        ctx.arc(-size*0.4, -size*0.35, size*0.25, 0, Math.PI*2);
        ctx.fill();
    }
    
    ctx.restore();
}

function drawCannon() {
    const cx = canvas.width / 2;
    const cy = (canvas.height / 2) + 50; 
    // Use AIM position instead of mouse position to rotate cannon
    const angle = Math.atan2(gameState.aimY - cy, gameState.aimX - cx);
    
    ctx.save();
    ctx.translate(cx, cy);
    
    // Mound
    ctx.fillStyle = '#1a100c';
    ctx.beginPath(); ctx.arc(0, 0, 45, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 6; ctx.stroke();
    
    ctx.rotate(angle);
    
    // --- UPDATED ANT VISUALS (More insect-like, better segmentation) ---
    const antPrimary = '#fbbf24';
    const antDark = '#b45309';
    const legColor = '#78350f';
    
    // LEGS (3 Pairs - Articulated)
    ctx.strokeStyle = legColor; 
    ctx.lineWidth = 4; 
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    // Rear Legs (Long, anchored at thorax)
    ctx.beginPath(); 
    ctx.moveTo(0, 0); 
    ctx.lineTo(-15, -20); 
    ctx.lineTo(-35, -45); 
    ctx.stroke();
    
    ctx.beginPath(); 
    ctx.moveTo(0, 0); 
    ctx.lineTo(-15, 20); 
    ctx.lineTo(-35, 45); 
    ctx.stroke();

    // Mid Legs
    ctx.beginPath(); 
    ctx.moveTo(10, 0); 
    ctx.lineTo(25, -25); 
    ctx.lineTo(45, -35); 
    ctx.stroke();
    
    ctx.beginPath(); 
    ctx.moveTo(10, 0); 
    ctx.lineTo(25, 25); 
    ctx.lineTo(45, 35); 
    ctx.stroke();

    // Front Legs
    ctx.beginPath(); 
    ctx.moveTo(20, 0); 
    ctx.lineTo(35, -20); 
    ctx.lineTo(50, -15); 
    ctx.stroke();
    
    ctx.beginPath(); 
    ctx.moveTo(20, 0); 
    ctx.lineTo(35, 20); 
    ctx.lineTo(50, 15); 
    ctx.stroke();
    
    // ABDOMEN (Rear - Large, bulbous)
    const abGrad = ctx.createRadialGradient(-30, 0, 5, -30, 0, 25);
    abGrad.addColorStop(0, antPrimary);
    abGrad.addColorStop(1, antDark);
    ctx.fillStyle = abGrad;
    ctx.beginPath();
    ctx.ellipse(-30, 0, 25, 18, 0, 0, Math.PI*2);
    ctx.fill();
    // Stripes
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath(); ctx.ellipse(-25, 0, 3, 14, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(-35, 0, 3, 16, 0, 0, Math.PI*2); ctx.fill();

    // THORAX (Middle)
    const thGrad = ctx.createRadialGradient(5, 0, 2, 5, 0, 15);
    thGrad.addColorStop(0, antPrimary);
    thGrad.addColorStop(1, antDark);
    ctx.fillStyle = thGrad;
    ctx.beginPath();
    ctx.ellipse(5, 0, 14, 10, 0, 0, Math.PI*2);
    ctx.fill();

    // HEAD (Front - Triangle shape)
    const hdGrad = ctx.createRadialGradient(30, 0, 2, 30, 0, 15);
    hdGrad.addColorStop(0, antPrimary);
    hdGrad.addColorStop(1, antDark);
    ctx.fillStyle = hdGrad;
    ctx.beginPath();
    // Custom head shape
    ctx.moveTo(20, -10);
    ctx.quadraticCurveTo(45, -15, 45, 0);
    ctx.quadraticCurveTo(45, 15, 20, 10);
    ctx.fill();
    
    // EYES (Large, compound)
    ctx.fillStyle = '#000'; 
    ctx.beginPath(); ctx.ellipse(38, -8, 5, 3, Math.PI/4, 0, Math.PI*2); ctx.fill(); 
    ctx.beginPath(); ctx.ellipse(38, 8, 5, 3, -Math.PI/4, 0, Math.PI*2); ctx.fill();
    // Shine
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(39, -9, 1.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(39, 9, 1.5, 0, Math.PI*2); ctx.fill();
    
    // MANDIBLES (Pincers)
    ctx.fillStyle = '#451a03'; 
    ctx.beginPath(); 
    // Left
    ctx.moveTo(42, -4); 
    ctx.quadraticCurveTo(60, -15, 55, -2); 
    ctx.lineTo(48, 0);
    ctx.fill();
    // Right
    ctx.beginPath();
    ctx.moveTo(42, 4); 
    ctx.quadraticCurveTo(60, 15, 55, 2); 
    ctx.lineTo(48, 0);
    ctx.fill();

    ctx.restore();
}

function drawProjectiles() {
    for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
        const p = gameState.projectiles[i];
        
        const dx = p.tx - p.x;
        const dy = p.ty - p.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist < p.speed) {
            resolveShot(p.isSuccess);
            gameState.projectiles.splice(i, 1);
            continue;
        }
        
        const vx = (dx/dist) * p.speed;
        const vy = (dy/dist) * p.speed;
        p.x += vx;
        p.y += vy;
        
        p.trail.push({x: p.x, y: p.y});
        if (p.trail.length > 10) p.trail.shift();

        if (p.trail.length > 1) {
            ctx.beginPath();
            ctx.moveTo(p.trail[0].x, p.trail[0].y);
            for (let j = 1; j < p.trail.length; j++) {
                ctx.lineTo(p.trail[j].x, p.trail[j].y);
            }
            ctx.lineCap = 'round';
            ctx.lineWidth = 5;
            ctx.strokeStyle = 'rgba(173, 255, 47, 0.4)'; 
            ctx.stroke();
        }

        const grad = ctx.createRadialGradient(p.x, p.y, 2, p.x, p.y, 12);
        grad.addColorStop(0, '#ffffff');      
        grad.addColorStop(0.3, '#ccff00');    
        grad.addColorStop(1, 'rgba(100, 255, 0, 0)');
        
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(p.x, p.y, 12, 0, Math.PI*2); ctx.fill();
    }
}

function drawParticles() {
    for (let i = gameState.particles.length - 1; i >= 0; i--) {
        const p = gameState.particles[i];
        
        if (p.isShockwave) {
            p.size += p.growth;
            p.life -= p.decay;
            if (p.life <= 0) { gameState.particles.splice(i, 1); continue; }
            ctx.strokeStyle = p.color;
            ctx.lineWidth = 3 * p.life;
            ctx.globalAlpha = p.life;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.stroke();
            ctx.globalAlpha = 1.0;
            continue;
        }

        p.x += p.vx;
        p.y += p.vy;
        p.life -= p.decay;
        
        if (p.life <= 0) { gameState.particles.splice(i, 1); continue; }
        
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

function drawFloatingTexts() {
    for (let i = gameState.floatingTexts.length - 1; i >= 0; i--) {
        const ft = gameState.floatingTexts[i];
        ft.y += ft.vy;
        ft.life -= 0.02;
        if (ft.life <= 0) { gameState.floatingTexts.splice(i, 1); continue; }
        
        ctx.save();
        ctx.globalAlpha = ft.life;
        ctx.translate(ft.x, ft.y);
        ctx.font = "900 36px 'Arial Black', sans-serif";
        ctx.textAlign = "center";
        
        // Use custom color if provided
        ctx.lineWidth = 6; ctx.strokeStyle = "black"; ctx.strokeText(ft.text, 0, 0);
        ctx.fillStyle = ft.color || "#fbbf24"; ctx.fillText(ft.text, 0, 0);
        ctx.restore();
    }
}

initGame();
</script>
</body>
</html>
