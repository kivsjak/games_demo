import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { Info, AlertTriangle } from 'lucide-react';

const ToTheMoonGame = () => {
  // Game State
  const [gameState, setGameState] = useState('menu');
  const [speed, setSpeed] = useState('LOW');
  const [betAmount, setBetAmount] = useState(10.00);
  const [autoplay, setAutoplay] = useState(false);
  const [showInfo, setShowInfo] = useState(false);
  
  // Bull position
  const [bullPos, setBullPos] = useState({ x: 50, y: 75 });
  const [targetPos, setTargetPos] = useState({ x: 50, y: 75 });
  const [distanceToMoon, setDistanceToMoon] = useState(382000);
  const [traveledDistance, setTraveledDistance] = useState(0);
  
  // Game stats
  const [totalWin, setTotalWin] = useState(0);
  const [bubblesCollected, setBubblesCollected] = useState(0);
  const [recentWin, setRecentWin] = useState(null);
  const [flightTime, setFlightTime] = useState(0);
  
  // Bubbles
  const [bubbles, setBubbles] = useState([]);
  const bubbleIdCounter = useRef(0);
  const lastBubbleSpawn = useRef(0);
  
  // Special bubbles tracking
  const specialCounts = useRef({
    galaxy_small_S2: 0,
    galaxy_small_S3: 0,
    blackhole_small_S2: 0,
    blackhole_small_S3: 0,
    supernova_small: 0,
    supernova_big: 0,
    gravity_small: 0,
    gravity_big: 0,
    wormhole_S1: false,
    wormhole_S3: false,
    wormhole_S5: false
  });
  
  const [activeSupernova, setActiveSupernova] = useState(null);
  const [activeGravity, setActiveGravity] = useState(null);
  const [wormholeActive, setWormholeActive] = useState(false);
  const [wormholeProgress, setWormholeProgress] = useState(0);
  const [warnings, setWarnings] = useState([]);
  
  // Animation
  const animationFrame = useRef(null);
  const lastUpdate = useRef(Date.now());
  const gameStartTime = useRef(null);
  const containerRef = useRef(null);
  
  // Generate static stars ONCE
  const staticStars = useMemo(() => {
    const stars = [];
    for (let i = 0; i < 80; i++) {
      stars.push({
        id: `star-${i}`,
        type: 'dot',
        x: Math.random() * 100,
        y: Math.random() * 100,
        size: i % 15 === 0 ? 3 : 2,
        opacity: 0.6
      });
    }
    for (let i = 0; i < 25; i++) {
      stars.push({
        id: `plus-${i}`,
        type: 'plus',
        x: Math.random() * 100,
        y: Math.random() * 100,
        opacity: 0.4
      });
    }
    for (let i = 0; i < 20; i++) {
      stars.push({
        id: `x-${i}`,
        type: 'x',
        x: Math.random() * 100,
        y: Math.random() * 100,
        opacity: 0.3
      });
    }
    return stars;
  }, []);
  
  // Multipliers (18 total - 6 per zone)
  const MULTIPLIERS = {
    left: [
      { value: 1.1, winChance: 90, color: '#86efac' },
      { value: 1.5, winChance: 85, color: '#4ade80' },
      { value: 2, winChance: 80, color: '#22c55e' },
      { value: 3, winChance: 75, color: '#16a34a' },
      { value: 5, winChance: 70, color: '#15803d' },
      { value: 8, winChance: 65, color: '#14532d' }
    ],
    center: [
      { value: 10, winChance: 60, color: '#a78bfa' },
      { value: 15, winChance: 55, color: '#8b5cf6' },
      { value: 25, winChance: 50, color: '#7c3aed' },
      { value: 32, winChance: 45, color: '#6d28d9' },
      { value: 64, winChance: 40, color: '#5b21b6' },
      { value: 100, winChance: 35, color: '#4c1d95' }
    ],
    right: [
      { value: 150, winChance: 30, color: '#fb923c' },
      { value: 200, winChance: 25, color: '#f97316' },
      { value: 300, winChance: 20, color: '#ea580c' },
      { value: 600, winChance: 15, color: '#fbbf24' },
      { value: 900, winChance: 10, color: '#f59e0b' },
      { value: 1200, winChance: 5, color: '#d97706' }
    ]
  };
  
  const SPEED_COEFFS = { LOW: 1.0, MEDIUM: 1.5, HIGH: 2.0 };
  
  // Get segment
  const getSegment = useCallback(() => {
    const progress = traveledDistance / 382000;
    if (progress < 0.10) return 'S1';
    if (progress < 0.25) return 'S2';
    if (progress < 0.45) return 'S3';
    if (progress < 0.65) return 'S4';
    if (progress < 0.85) return 'S5';
    return 'S6';
  }, [traveledDistance]);
  
  // Segment configurations
  const SEGMENT_CONFIG = {
    S1: { groupSizes: [1, 2, 3], probabilities: [0.70, 0.25, 0.05], density: 8 },
    S2: { groupSizes: [1, 2, 3, 4], probabilities: [0.10, 0.40, 0.30, 0.20], density: 12 },
    S3: { groupSizes: [3, 4, 6], probabilities: [0.30, 0.55, 0.15], density: 15 },
    S4: { groupSizes: [4, 6, 8, 10, 12], probabilities: [0.15, 0.55, 0.15, 0.10, 0.05], density: 18 },
    S5: { groupSizes: [8, 10, 12, 14, 16], probabilities: [0.45, 0.25, 0.15, 0.10, 0.05], density: 22 },
    S6: { groupSizes: [10, 12, 14, 16, 18, 20], probabilities: [0.15, 0.15, 0.20, 0.20, 0.15, 0.15], density: 25 }
  };
  
  // Simulate Dice API call
  const callDiceAPI = useCallback(async (bet, multiplier, winChance) => {
    await new Promise(resolve => setTimeout(resolve, 20));
    const won = Math.random() * 100 < winChance;
    const payout = won ? bet * multiplier : 0;
    return { won, payout, multiplier };
  }, []);
  
  // Generate Galaxy bubble
  const generateGalaxyBubble = useCallback((segment, yPos, size) => {
    const id = bubbleIdCounter.current++;
    const xCenter = 50;
    
    let multiplier;
    if (size === 'small') {
      multiplier = MULTIPLIERS.center[1]; // 15x
    } else {
      multiplier = MULTIPLIERS.center[3]; // 32x
    }
    
    const innerCount = size === 'small' ? 4 : 10;
    
    return [{
      id,
      x: xCenter,
      y: yPos,
      type: 'galaxy',
      size,
      innerCount,
      multiplier: multiplier.value,
      winChance: multiplier.winChance,
      color: '#a855f7',
      collected: false
    }];
  }, []);
  
  // Generate Black Hole bubble
  const generateBlackHoleBubble = useCallback((segment, yPos, size) => {
    const id = bubbleIdCounter.current++;
    const xCenter = 50;
    
    const innerMultipliers = size === 'small' 
      ? [
          { value: 10, winChance: 60 },
          { value: 25, winChance: 50 },
          { value: 32, winChance: 45 },
          { value: 64, winChance: 40 }
        ]
      : [
          { value: 10, winChance: 60 },
          { value: 15, winChance: 55 },
          { value: 25, winChance: 50 },
          { value: 32, winChance: 45 },
          { value: 64, winChance: 40 },
          { value: 100, winChance: 35 },
          { value: 150, winChance: 30 },
          { value: 200, winChance: 25 },
          { value: 300, winChance: 20 }
        ];
    
    return [{
      id,
      x: xCenter,
      y: yPos,
      type: 'blackhole',
      size,
      innerMultipliers,
      color: '#1e1b4b',
      collected: false
    }];
  }, []);
  
  // Generate Supernova bubble
  const generateSupernovaBubble = useCallback((segment, yPos, size) => {
    const id = bubbleIdCounter.current++;
    const xCenter = 50;
    
    return [{
      id,
      x: xCenter,
      y: yPos,
      type: 'supernova',
      size,
      radius: size === 'small' ? 25 : 100,
      color: '#fbbf24',
      collected: false
    }];
  }, []);
  
  // Generate Gravity bubble
  const generateGravityBubble = useCallback((segment, yPos, size) => {
    const id = bubbleIdCounter.current++;
    const xCenter = 50;
    
    let multiplier;
    if (size === 'small') {
      multiplier = { value: 2, winChance: 80 };
    } else {
      multiplier = { value: 5, winChance: 70 };
    }
    
    return [{
      id,
      x: xCenter,
      y: yPos,
      type: 'gravity',
      size,
      radius: size === 'small' ? 25 : 100,
      multiplier: multiplier.value,
      winChance: multiplier.winChance,
      color: '#3b82f6',
      collected: false,
      pulledCount: 0
    }];
  }, []);
  
  // Generate regular bubble group
  const generateRegularBubbleGroup = useCallback((groupSize, segment, yPos) => {
    const zoneRandom = Math.random();
    let zone, xStart;
    if (zoneRandom < 0.33) {
      zone = 'left';
      xStart = 15;
    } else if (zoneRandom < 0.66) {
      zone = 'center';
      xStart = 45;
    } else {
      zone = 'right';
      xStart = 75;
    }
    
    const multiplierIndex = Math.floor(Math.random() * MULTIPLIERS[zone].length);
    const multiplier = MULTIPLIERS[zone][multiplierIndex];
    
    const newBubbles = [];
    const horizontalSpacing = 10;
    const verticalSpacing = 10;
    
    let cols, rows;
    if (groupSize <= 4) {
      cols = groupSize;
      rows = 1;
    } else if (groupSize <= 10) {
      cols = Math.ceil(groupSize / 2);
      rows = 2;
    } else {
      cols = Math.min(5, Math.ceil(Math.sqrt(groupSize)));
      rows = Math.ceil(groupSize / cols);
    }
    
    const totalWidth = (cols - 1) * horizontalSpacing;
    const startX = xStart - totalWidth / 2;
    
    for (let i = 0; i < groupSize; i++) {
      const id = bubbleIdCounter.current++;
      const col = i % cols;
      const row = Math.floor(i / cols);
      
      newBubbles.push({
        id,
        x: startX + col * horizontalSpacing,
        y: yPos - row * verticalSpacing,
        multiplier: multiplier.value,
        winChance: multiplier.winChance,
        color: multiplier.color,
        collected: false,
        type: 'regular',
        zone
      });
    }
    
    return newBubbles;
  }, []);
  
  // Generate bubble group with special bubble logic
  const generateBubbleGroup = useCallback((segment, yPos) => {
    const config = SEGMENT_CONFIG[segment];
    const random = Math.random();
    
    let groupSize = config.groupSizes[0];
    let cumulative = 0;
    for (let i = 0; i < config.probabilities.length; i++) {
      cumulative += config.probabilities[i];
      if (random < cumulative) {
        groupSize = config.groupSizes[i];
        break;
      }
    }
    
    // Small Galaxy/BlackHole: S2-S3, k=4, 2 per segment
    if ((segment === 'S2' || segment === 'S3') && groupSize === 4) {
      const galaxyKey = `galaxy_small_${segment}`;
      const bhKey = `blackhole_small_${segment}`;
      
      if (specialCounts.current[galaxyKey] < 2 && Math.random() < 0.25) {
        specialCounts.current[galaxyKey]++;
        return generateGalaxyBubble(segment, yPos, 'small');
      }
      
      if (specialCounts.current[bhKey] < 2 && Math.random() < 0.25) {
        specialCounts.current[bhKey]++;
        return generateBlackHoleBubble(segment, yPos, 'small');
      }
    }
    
    // Big Galaxy/BlackHole: S4-S6, k‚àà{10,12,14,16,18,20}
    if ((segment === 'S4' || segment === 'S5' || segment === 'S6') && 
        [10, 12, 14, 16, 18, 20].includes(groupSize)) {
      
      if (Math.random() < 0.12) {
        return generateGalaxyBubble(segment, yPos, 'big');
      }
      
      if (Math.random() < 0.12) {
        return generateBlackHoleBubble(segment, yPos, 'big');
      }
    }
    
    // Small Supernova: S1-S4
    if (['S1', 'S2', 'S3', 'S4'].includes(segment) && 
        specialCounts.current.supernova_small < 4 && 
        Math.random() < 0.02) {
      specialCounts.current.supernova_small++;
      // Show warning
      setWarnings(prev => [...prev, { id: Date.now(), type: 'supernova', size: 'small' }]);
      setTimeout(() => {
        setWarnings(prev => prev.filter(w => w.id !== Date.now()));
      }, 2000);
      return generateSupernovaBubble(segment, yPos, 'small');
    }
    
    // Big Supernova: S4-S6
    if (['S4', 'S5', 'S6'].includes(segment) && 
        specialCounts.current.supernova_big < 2 && 
        !activeSupernova &&
        Math.random() < 0.01) {
      specialCounts.current.supernova_big++;
      setWarnings(prev => [...prev, { id: Date.now(), type: 'supernova', size: 'big' }]);
      setTimeout(() => {
        setWarnings(prev => prev.filter(w => w.id !== Date.now()));
      }, 2000);
      return generateSupernovaBubble(segment, yPos, 'big');
    }
    
    // Small Gravity: S1-S4
    if (['S1', 'S2', 'S3', 'S4'].includes(segment) && 
        specialCounts.current.gravity_small < 4 && 
        Math.random() < 0.02) {
      specialCounts.current.gravity_small++;
      setWarnings(prev => [...prev, { id: Date.now(), type: 'gravity', size: 'small' }]);
      setTimeout(() => {
        setWarnings(prev => prev.filter(w => w.id !== Date.now()));
      }, 2000);
      return generateGravityBubble(segment, yPos, 'small');
    }
    
    // Big Gravity: S4-S6
    if (['S4', 'S5', 'S6'].includes(segment) && 
        specialCounts.current.gravity_big < 2 && 
        !activeGravity &&
        Math.random() < 0.01) {
      specialCounts.current.gravity_big++;
      setWarnings(prev => [...prev, { id: Date.now(), type: 'gravity', size: 'big' }]);
      setTimeout(() => {
        setWarnings(prev => prev.filter(w => w.id !== Date.now()));
      }, 2000);
      return generateGravityBubble(segment, yPos, 'big');
    }
    
    return generateRegularBubbleGroup(groupSize, segment, yPos);
  }, [generateGalaxyBubble, generateBlackHoleBubble, generateSupernovaBubble, generateGravityBubble, generateRegularBubbleGroup, activeSupernova, activeGravity]);
  
  // Check for Wormhole spawn
  const checkWormholeSpawn = useCallback((segment) => {
    const progress = traveledDistance / 382000;
    
    // Wormhole at end of S1 (9-10%)
    if (segment === 'S1' && progress > 0.09 && !specialCounts.current.wormhole_S1) {
      specialCounts.current.wormhole_S1 = true;
      setWarnings(prev => [...prev, { id: Date.now(), type: 'wormhole', segment: 'S1' }]);
      setTimeout(() => {
        setWormholeActive(true);
        setWormholeProgress(0);
      }, 2000);
    }
    
    // Wormhole at end of S3 (43-45%)
    if (segment === 'S3' && progress > 0.43 && !specialCounts.current.wormhole_S3) {
      specialCounts.current.wormhole_S3 = true;
      setWarnings(prev => [...prev, { id: Date.now(), type: 'wormhole', segment: 'S3' }]);
      setTimeout(() => {
        setWormholeActive(true);
        setWormholeProgress(0);
      }, 2000);
    }
    
    // Wormhole at end of S5 (83-85%)
    if (segment === 'S5' && progress > 0.83 && !specialCounts.current.wormhole_S5) {
      specialCounts.current.wormhole_S5 = true;
      setWarnings(prev => [...prev, { id: Date.now(), type: 'wormhole', segment: 'S5' }]);
      setTimeout(() => {
        setWormholeActive(true);
        setWormholeProgress(0);
      }, 2000);
    }
  }, [traveledDistance]);
  
  // Collect regular bubble
  const collectBubble = useCallback(async (bubble) => {
    const result = await callDiceAPI(betAmount, bubble.multiplier, bubble.winChance);
    
    setBubblesCollected(prev => prev + 1);
    
    if (result.won) {
      setTotalWin(prev => prev + result.payout);
      setRecentWin(result.payout);
      setTimeout(() => setRecentWin(null), 2000);
    }
  }, [betAmount, callDiceAPI]);
  
  // Collect Galaxy bubble
  const collectGalaxy = useCallback(async (bubble) => {
    const splitBet = betAmount / bubble.innerCount;
    let totalPayout = 0;
    
    for (let i = 0; i < bubble.innerCount; i++) {
      const result = await callDiceAPI(splitBet, bubble.multiplier, bubble.winChance);
      if (result.won) {
        totalPayout += result.payout;
      }
    }
    
    setBubblesCollected(prev => prev + 1);
    
    if (totalPayout > 0) {
      setTotalWin(prev => prev + totalPayout);
      setRecentWin(totalPayout);
      setTimeout(() => setRecentWin(null), 2000);
    }
  }, [betAmount, callDiceAPI]);
  
  // Collect Black Hole bubble
  const collectBlackHole = useCallback(async (bubble) => {
    const splitBet = betAmount / bubble.innerMultipliers.length;
    let totalPayout = 0;
    
    for (let i = 0; i < bubble.innerMultipliers.length; i++) {
      const mult = bubble.innerMultipliers[i];
      const result = await callDiceAPI(splitBet, mult.value, mult.winChance);
      if (result.won) {
        totalPayout += result.payout;
      }
    }
    
    setBubblesCollected(prev => prev + 1);
    
    if (totalPayout > 0) {
      setTotalWin(prev => prev + totalPayout);
      setRecentWin(totalPayout);
      setTimeout(() => setRecentWin(null), 2000);
    }
  }, [betAmount, callDiceAPI]);
  
  // Collect Supernova
  const collectSupernova = useCallback(async (bubble) => {
    setActiveSupernova(bubble);
    
    // Find all bubbles in radius
    const affectedBubbles = bubbles.filter(b => {
      if (b.id === bubble.id || b.collected) return false;
      const dist = Math.sqrt(Math.pow(b.x - bubble.x, 2) + Math.pow(b.y - bubble.y, 2));
      return dist < bubble.radius;
    });
    
    // Trigger all bubbles
    let totalPayout = 0;
    for (const b of affectedBubbles) {
      if (b.type === 'regular') {
        const result = await callDiceAPI(betAmount, b.multiplier, b.winChance);
        if (result.won) totalPayout += result.payout;
      }
      b.collected = true;
    }
    
    setBubblesCollected(prev => prev + affectedBubbles.length + 1);
    
    if (totalPayout > 0) {
      setTotalWin(prev => prev + totalPayout);
      setRecentWin(totalPayout);
      setTimeout(() => setRecentWin(null), 2000);
    }
    
    setTimeout(() => setActiveSupernova(null), 1000);
  }, [bubbles, betAmount, callDiceAPI]);
  
  // Collect Gravity
  const collectGravity = useCallback(async (bubble) => {
    setActiveGravity(bubble);
    
    // Find all bubbles in radius
    const affectedBubbles = bubbles.filter(b => {
      if (b.id === bubble.id || b.collected) return false;
      const dist = Math.sqrt(Math.pow(b.x - bubble.x, 2) + Math.pow(b.y - bubble.y, 2));
      return dist < bubble.radius;
    });
    
    bubble.pulledCount = affectedBubbles.length;
    
    // Convert to gravity multiplier and trigger
    let totalPayout = 0;
    for (const b of affectedBubbles) {
      const result = await callDiceAPI(betAmount, bubble.multiplier, bubble.winChance);
      if (result.won) totalPayout += result.payout;
      b.collected = true;
    }
    
    setBubblesCollected(prev => prev + affectedBubbles.length + 1);
    
    if (totalPayout > 0) {
      setTotalWin(prev => prev + totalPayout);
      setRecentWin(totalPayout);
      setTimeout(() => setRecentWin(null), 2000);
    }
    
    setTimeout(() => setActiveGravity(null), 1000);
  }, [bubbles, betAmount, callDiceAPI]);
  
  // Start game
  const startGame = useCallback(() => {
    setGameState('playing');
    setDistanceToMoon(382000);
    setTraveledDistance(0);
    setTotalWin(0);
    setBubblesCollected(0);
    setRecentWin(null);
    setFlightTime(0);
    setBubbles([]);
    setBullPos({ x: 50, y: 75 });
    setTargetPos({ x: 50, y: 75 });
    gameStartTime.current = Date.now();
    lastBubbleSpawn.current = Date.now();
    
    // Reset special counters
    specialCounts.current = {
      galaxy_small_S2: 0,
      galaxy_small_S3: 0,
      blackhole_small_S2: 0,
      blackhole_small_S3: 0,
      supernova_small: 0,
      supernova_big: 0,
      gravity_small: 0,
      gravity_big: 0,
      wormhole_S1: false,
      wormhole_S3: false,
      wormhole_S5: false
    };
    
    const initialBubbles = [];
    for (let i = 0; i < 6; i++) {
      const yPos = 50 - i * 12;
      const group = generateBubbleGroup('S1', yPos);
      initialBubbles.push(...group);
    }
    setBubbles(initialBubbles);
  }, [generateBubbleGroup]);
  
  // Handle movement
  const handleMove = useCallback((e) => {
    if (gameState !== 'playing' || !containerRef.current || wormholeActive) return;
    
    const rect = containerRef.current.getBoundingClientRect();
    let clientX, clientY;
    
    if (e.type.includes('touch')) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    
    const x = ((clientX - rect.left) / rect.width) * 100;
    const y = ((clientY - rect.top) / rect.height) * 100;
    
    setTargetPos({ 
      x: Math.max(5, Math.min(95, x)), 
      y: Math.max(10, Math.min(85, y)) 
    });
  }, [gameState, wormholeActive]);
  
  // Main game loop
  useEffect(() => {
    if (gameState !== 'playing') return;
    
    let currentBullPos = { ...bullPos };
    
    const gameLoop = () => {
      const now = Date.now();
      const deltaTime = Math.min((now - lastUpdate.current) / 1000, 0.1);
      lastUpdate.current = now;
      
      if (gameStartTime.current) {
        setFlightTime(Math.floor((now - gameStartTime.current) / 1000));
      }
      
      // Wormhole mode
      if (wormholeActive) {
        setWormholeProgress(prev => {
          const newProgress = prev + deltaTime * 20;
          if (newProgress >= 100) {
            setWormholeActive(false);
            // Skip segment
            setTraveledDistance(prevDist => prevDist + 50000);
            return 0;
          }
          return newProgress;
        });
        
        animationFrame.current = requestAnimationFrame(gameLoop);
        return;
      }
      
      // Update bull
      const dx = targetPos.x - currentBullPos.x;
      const dy = targetPos.y - currentBullPos.y;
      const moveSpeed = 8;
      
      currentBullPos = {
        x: currentBullPos.x + dx * moveSpeed * deltaTime,
        y: currentBullPos.y + dy * moveSpeed * deltaTime
      };
      
      setBullPos(currentBullPos);
      
      // Move bubbles
      const speedCoeff = SPEED_COEFFS[speed];
      const scrollSpeed = 12 * speedCoeff;
      
      setBubbles(prev => {
        const remaining = [];
        
        prev.forEach(bubble => {
          if (bubble.collected) return;
          
          const newY = bubble.y + scrollSpeed * deltaTime;
          
          if (newY > 105) return;
          
          // Collision check
          const dist = Math.sqrt(
            Math.pow(bubble.x - currentBullPos.x, 2) + 
            Math.pow(newY - currentBullPos.y, 2)
          );
          
          const collisionRadius = bubble.type === 'regular' ? 2.5 : 4;
          
          if (dist < collisionRadius) {
            bubble.collected = true;
            
            if (bubble.type === 'galaxy') {
              collectGalaxy(bubble);
            } else if (bubble.type === 'blackhole') {
              collectBlackHole(bubble);
            } else if (bubble.type === 'supernova') {
              collectSupernova(bubble);
            } else if (bubble.type === 'gravity') {
              collectGravity(bubble);
            } else {
              collectBubble(bubble);
            }
            return;
          }
          
          remaining.push({ ...bubble, y: newY });
        });
        
        return remaining;
      });
      
      // Update distance
      setTraveledDistance(prev => {
        const distanceIncrement = scrollSpeed * deltaTime * 200;
        const newTraveled = prev + distanceIncrement;
        
        const remaining = Math.max(0, 382000 - newTraveled);
        setDistanceToMoon(Math.floor(remaining));
        
        if (remaining <= 0 && gameState === 'playing') {
          setGameState('finished');
        }
        
        return newTraveled;
      });
      
      // Check wormhole spawn
      const segment = getSegment();
      checkWormholeSpawn(segment);
      
      // Spawn bubbles
      const config = SEGMENT_CONFIG[segment];
      const timeSinceLastSpawn = now - lastBubbleSpawn.current;
      const spawnInterval = Math.max(800, (1500 / config.density) * (1 / speedCoeff));
      
      if (timeSinceLastSpawn > spawnInterval) {
        lastBubbleSpawn.current = now;
        const yPos = -10;
        const newBubbles = generateBubbleGroup(segment, yPos);
        
        setBubbles(prev => {
          const combined = [...prev, ...newBubbles];
          return combined.slice(-50);
        });
      }
      
      animationFrame.current = requestAnimationFrame(gameLoop);
    };
    
    animationFrame.current = requestAnimationFrame(gameLoop);
    
    return () => {
      if (animationFrame.current) {
        cancelAnimationFrame(animationFrame.current);
      }
    };
  }, [gameState, speed, targetPos, bullPos, wormholeActive, getSegment, checkWormholeSpawn, generateBubbleGroup, collectBubble, collectGalaxy, collectBlackHole, collectSupernova, collectGravity]);
  
  return (
    <div className="w-full h-screen bg-gradient-to-b from-indigo-950 via-purple-900 to-purple-950 overflow-hidden relative">
      {/* Static stars */}
      <div className="absolute inset-0 pointer-events-none">
        {staticStars.map(star => {
          if (star.type === 'dot') {
            return (
              <div
                key={star.id}
                className="absolute bg-white rounded-full"
                style={{
                  left: `${star.x}%`,
                  top: `${star.y}%`,
                  width: `${star.size}px`,
                  height: `${star.size}px`,
                  opacity: star.opacity
                }}
              />
            );
          } else if (star.type === 'plus') {
            return (
              <div
                key={star.id}
                className="absolute text-white"
                style={{
                  left: `${star.x}%`,
                  top: `${star.y}%`,
                  fontSize: '14px',
                  opacity: star.opacity
                }}
              >
                +
              </div>
            );
          } else {
            return (
              <div
                key={star.id}
                className="absolute text-white"
                style={{
                  left: `${star.x}%`,
                  top: `${star.y}%`,
                  fontSize: '12px',
                  opacity: star.opacity
                }}
              >
                √ó
              </div>
            );
          }
        })}
      </div>
      
      {/* Pink clouds */}
      <div className="absolute bottom-0 left-0 w-1/3 h-1/4 opacity-50 pointer-events-none">
        <svg viewBox="0 0 200 100" className="w-full h-full">
          <ellipse cx="50" cy="70" rx="50" ry="30" fill="#e9d5ff"/>
          <ellipse cx="80" cy="75" rx="40" ry="25" fill="#f3e8ff"/>
          <ellipse cx="30" cy="80" rx="35" ry="20" fill="#ddd6fe"/>
        </svg>
      </div>
      
      <div className="absolute bottom-0 right-0 w-1/3 h-1/4 opacity-50 pointer-events-none">
        <svg viewBox="0 0 200 100" className="w-full h-full">
          <ellipse cx="150" cy="70" rx="50" ry="30" fill="#e9d5ff"/>
          <ellipse cx="120" cy="75" rx="40" ry="25" fill="#f3e8ff"/>
          <ellipse cx="170" cy="80" rx="35" ry="20" fill="#ddd6fe"/>
        </svg>
      </div>
      
      {/* Game container */}
      <div
        ref={containerRef}
        className="relative w-full h-full"
        onMouseMove={handleMove}
        onTouchMove={handleMove}
      >
        {/* Warnings */}
        {warnings.map(warning => (
          <div
            key={warning.id}
            className="absolute top-1/4 left-1/2 transform -translate-x-1/2 z-50 animate-pulse"
          >
            <div className="bg-red-600 text-white px-6 py-3 rounded-xl border-4 border-red-400 shadow-2xl flex items-center gap-3">
              <AlertTriangle className="w-8 h-8" />
              <div className="font-bold text-xl">
                {warning.type === 'wormhole' && 'üåÄ WORMHOLE AHEAD!'}
                {warning.type === 'supernova' && 'üí• SUPERNOVA!'}
                {warning.type === 'gravity' && 'üåÄ GRAVITY WAVE!'}
              </div>
            </div>
          </div>
        ))}
        
        {/* Wormhole screen */}
        {wormholeActive && (
          <div className="absolute inset-0 bg-gradient-to-b from-pink-900 via-purple-900 to-indigo-900 z-40 flex items-center justify-center">
            <div className="text-center">
              <div className="text-8xl mb-4 animate-spin">üåÄ</div>
              <div className="text-4xl font-bold text-white mb-4">WORMHOLE!</div>
              <div className="text-2xl text-purple-300">Traveling through space-time...</div>
              <div className="mt-8 w-64 h-4 bg-purple-950 rounded-full overflow-hidden">
                <div
                  className="h-full bg-gradient-to-r from-pink-500 to-purple-500 transition-all"
                  style={{ width: `${wormholeProgress}%` }}
                />
              </div>
            </div>
          </div>
        )}
        
        {/* Menu */}
        {gameState === 'menu' && (
          <div className="absolute inset-0 flex items-center justify-center z-50">
            <div className="bg-gradient-to-br from-amber-900/95 to-orange-950/95 rounded-3xl p-8 border-4 border-amber-700 shadow-2xl max-w-md w-full mx-4">
              <h1 className="text-5xl font-bold text-center mb-6" style={{
                color: '#fef3c7',
                textShadow: '2px 2px 4px rgba(0,0,0,0.5)'
              }}>
                üêÇ TO THE MOOOON üåô
              </h1>
              
              <div className="mb-4">
                <div className="bg-orange-950/60 rounded-xl p-3 border-2 border-orange-800">
                  <div className="text-amber-200 text-sm text-center mb-2 font-bold">SPEED: {speed}</div>
                  <div className="flex gap-2">
                    {['LOW', 'MEDIUM', 'HIGH'].map((s, i) => (
                      <button
                        key={s}
                        onClick={() => setSpeed(s)}
                        className={`flex-1 py-2 rounded-lg font-bold text-sm ${
                          speed === s ? 'opacity-100' : 'opacity-70'
                        } ${
                          i === 0 ? 'bg-green-600 text-white' :
                          i === 1 ? 'bg-orange-600 text-white' :
                          'bg-red-600 text-white'
                        }`}
                      >
                        {s}
                      </button>
                    ))}
                  </div>
                </div>
              </div>
              
              <div className="mb-6">
                <div className="bg-orange-950/60 rounded-xl p-4 border-2 border-orange-800">
                  <div className="text-amber-200 text-sm text-center mb-2 font-bold">BET AMOUNT</div>
                  <div className="flex items-center justify-between gap-2">
                    <button
                      onClick={() => setBetAmount(prev => Math.max(1, prev / 2))}
                      className="bg-orange-800 hover:bg-orange-700 text-amber-200 px-3 py-2 rounded-lg font-bold text-sm"
                    >
                      ¬Ω
                    </button>
                    <div className="flex-1 bg-orange-900 rounded-lg py-2 text-center">
                      <span className="text-xl font-bold text-amber-100">${betAmount.toFixed(2)}</span>
                    </div>
                    <button
                      onClick={() => setBetAmount(prev => Math.min(1000, prev * 2))}
                      className="bg-orange-800 hover:bg-orange-700 text-amber-200 px-3 py-2 rounded-lg font-bold text-sm"
                    >
                      2√ó
                    </button>
                  </div>
                  <div className="flex gap-2 mt-2">
                    <button
                      onClick={() => setBetAmount(1)}
                      className="flex-1 bg-orange-800 hover:bg-orange-700 text-amber-200 py-1 rounded-lg font-bold text-sm"
                    >
                      MIN
                    </button>
                    <button
                      onClick={() => setBetAmount(100)}
                      className="flex-1 bg-orange-800 hover:bg-orange-700 text-amber-200 py-1 rounded-lg font-bold text-sm"
                    >
                      MAX
                    </button>
                  </div>
                </div>
              </div>
              
              <div className="flex gap-3 mb-4">
                <button
                  onClick={() => setShowInfo(!showInfo)}
                  className="bg-purple-700 hover:bg-purple-600 text-white p-3 rounded-full shadow-lg"
                >
                  <Info className="w-5 h-5" />
                </button>
                
                <button
                  onClick={startGame}
                  className="flex-1 bg-gradient-to-b from-cyan-400 to-cyan-600 hover:from-cyan-500 hover:to-cyan-700 text-white py-3 px-6 rounded-2xl font-bold text-lg shadow-xl border-2 border-cyan-300"
                >
                  START
                </button>
                
                <button
                  onClick={() => setAutoplay(!autoplay)}
                  className={`p-3 rounded-full shadow-lg ${autoplay ? 'bg-green-600' : 'bg-orange-700'} text-white`}
                >
                  <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M10 2a8 8 0 100 16 8 8 0 000-16zm0 14a6 6 0 110-12 6 6 0 010 12z"/>
                  </svg>
                </button>
              </div>
              
              {showInfo && (
                <div className="bg-orange-950/70 rounded-xl p-4 border-2 border-orange-700 text-amber-200 text-xs">
                  <h3 className="font-bold mb-2">–°–ø–µ—Ü—ñ–∞–ª—å–Ω—ñ –±—É–ª—å–±–∞—à–∫–∏:</h3>
                  <ul className="space-y-1">
                    <li>üåå <strong>Galaxy</strong> - —Ñ—ñ–æ–ª–µ—Ç–æ–≤–∞ –∑ 4-10 –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ</li>
                    <li>‚ö´ <strong>Black Hole</strong> - —Ç–µ–º–Ω–∞ –∑ —Ä—ñ–∑–Ω–∏–º–∏ –º–Ω–æ–∂–Ω–∏–∫–∞–º–∏</li>
                    <li>üí• <strong>Supernova</strong> - –≤–∏–±—É—Ö–∞—î, –∞–∫—Ç–∏–≤—É—î –≤—Å—ñ –Ω–∞–≤–∫–æ–ª–æ</li>
                    <li>üåÄ <strong>Gravity</strong> - –ø—Ä–∏—Ç—è–≥—É—î –±—É–ª—å–±–∞—à–∫–∏</li>
                    <li>üåÄ <strong>Wormhole</strong> - –ø–æ—Ä—Ç–∞–ª, –ø—Ä–æ–ø—É—Å–∫–∞—î —Å–µ–≥–º–µ–Ω—Ç</li>
                  </ul>
                </div>
              )}
            </div>
          </div>
        )}
        
        {/* Playing */}
        {gameState === 'playing' && !wormholeActive && (
          <>
            {/* Moon */}
            <div className="absolute top-4 right-4 z-40">
              <div className="relative">
                <div className="absolute -inset-4 -z-10">
                  <svg viewBox="0 0 120 80" className="w-32 h-20">
                    <ellipse cx="60" cy="40" rx="50" ry="30" fill="#f3e8ff" opacity="0.7"/>
                    <ellipse cx="70" cy="45" rx="40" ry="25" fill="#e9d5ff" opacity="0.8"/>
                  </svg>
                </div>
                <div className="text-6xl mb-1">üåô</div>
                <div className="bg-gradient-to-b from-amber-100 to-amber-200 px-3 py-1 rounded-lg border-2 border-amber-800 shadow-lg transform -rotate-2">
                  <div className="text-purple-900 font-bold text-xs text-center">Moooon</div>
                  <div className="text-purple-900 font-bold text-sm text-center whitespace-nowrap">
                    {distanceToMoon.toLocaleString()} km
                  </div>
                </div>
              </div>
            </div>
            
            {/* Bull */}
            <div
              className="absolute will-change-transform z-30"
              style={{
                left: `${bullPos.x}%`,
                top: `${bullPos.y}%`,
                transform: 'translate3d(-50%, -50%, 0)'
              }}
            >
              <div className="relative">
                {recentWin && (
                  <div className="absolute -top-20 left-1/2 transform -translate-x-1/2 animate-bounce">
                    <div className="text-5xl font-black whitespace-nowrap" style={{
                      color: '#4ade80',
                      textShadow: '0 0 10px #000, 3px 3px 0 #000, -3px -3px 0 #000, 3px -3px 0 #000, -3px 3px 0 #000'
                    }}>
                      +${recentWin.toFixed(2)}
                    </div>
                  </div>
                )}
                
                <div className="absolute -bottom-2 left-1/2 transform -translate-x-1/2 flex gap-1">
                  <div className="w-1 h-10 bg-gradient-to-b from-blue-400 to-transparent opacity-80"></div>
                  <div className="w-1 h-12 bg-gradient-to-b from-cyan-300 to-transparent opacity-90"></div>
                  <div className="w-1 h-8 bg-gradient-to-b from-blue-300 to-transparent opacity-70"></div>
                </div>
                
                <div className="text-6xl filter drop-shadow-lg">üêÇ</div>
              </div>
            </div>
            
            {/* Bubbles */}
            {bubbles.map(bubble => (
              <div
                key={bubble.id}
                className="absolute will-change-transform z-20"
                style={{
                  left: `${bubble.x}%`,
                  top: `${bubble.y}%`,
                  transform: 'translate3d(-50%, -50%, 0)'
                }}
              >
                {bubble.type === 'regular' && (
                  <div
                    className="rounded-full flex items-center justify-center shadow-lg"
                    style={{
                      width: '48px',
                      height: '48px',
                      background: `radial-gradient(circle at 35% 35%, ${bubble.color}dd, ${bubble.color}aa)`,
                      border: `3px solid ${bubble.color}cc`,
                      boxShadow: `0 0 20px ${bubble.color}88, inset 0 0 12px rgba(255,255,255,0.4)`
                    }}
                  >
                    <span className="text-white font-bold text-sm drop-shadow-lg">
                      {bubble.multiplier}√ó
                    </span>
                  </div>
                )}
                
                {bubble.type === 'galaxy' && (
                  <div className="relative">
                    <div
                      className="rounded-full flex items-center justify-center shadow-2xl animate-pulse"
                      style={{
                        width: bubble.size === 'small' ? '70px' : '100px',
                        height: bubble.size === 'small' ? '70px' : '100px',
                        background: `radial-gradient(circle, #a855f7, #7c3aed)`,
                        border: '4px solid #c084fc',
                        boxShadow: '0 0 40px #a855f7'
                      }}
                    >
                      <div className="text-center">
                        <div className="text-white font-bold text-xl">üåå</div>
                        <div className="text-white font-bold text-xs">{bubble.innerCount}√ó{bubble.multiplier}√ó</div>
                      </div>
                    </div>
                  </div>
                )}
                
                {bubble.type === 'blackhole' && (
                  <div className="relative">
                    <div
                      className="rounded-full flex items-center justify-center shadow-2xl"
                      style={{
                        width: bubble.size === 'small' ? '70px' : '100px',
                        height: bubble.size === 'small' ? '70px' : '100px',
                        background: `radial-gradient(circle, #000000, #1e1b4b)`,
                        border: '4px solid #312e81',
                        boxShadow: '0 0 40px #000000'
                      }}
                    >
                      <div className="text-center">
                        <div className="text-white font-bold text-xl">‚ö´</div>
                        <div className="text-white font-bold text-xs">MIXED</div>
                      </div>
                    </div>
                  </div>
                )}
                
                {bubble.type === 'supernova' && (
                  <div className="relative animate-pulse">
                    <div
                      className="rounded-full flex items-center justify-center shadow-2xl"
                      style={{
                        width: bubble.size === 'small' ? '70px' : '100px',
                        height: bubble.size === 'small' ? '70px' : '100px',
                        background: `radial-gradient(circle, #fbbf24, #f59e0b)`,
                        border: '4px solid #fcd34d',
                        boxShadow: '0 0 50px #fbbf24'
                      }}
                    >
                      <div className="text-4xl">üí•</div>
                    </div>
                  </div>
                )}
                
                {bubble.type === 'gravity' && (
                  <div className="relative">
                    <div
                      className="rounded-full flex items-center justify-center shadow-2xl animate-pulse"
                      style={{
                        width: bubble.size === 'small' ? '70px' : '100px',
                        height: bubble.size === 'small' ? '70px' : '100px',
                        background: `radial-gradient(circle, #3b82f6, #1e40af)`,
                        border: '4px solid #60a5fa',
                        boxShadow: '0 0 50px #3b82f6'
                      }}
                    >
                      <div className="text-center">
                        <div className="text-3xl">üåÄ</div>
                        {bubble.pulledCount > 0 && (
                          <div className="text-white font-bold text-sm">{bubble.pulledCount}</div>
                        )}
                      </div>
                    </div>
                  </div>
                )}
              </div>
            ))}
            
            {/* Bottom UI */}
            <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 w-full max-w-md px-4 z-50">
              <div className="bg-gradient-to-b from-amber-900 to-orange-950 rounded-3xl p-4 border-4 border-amber-800 shadow-2xl">
                <div className="bg-gradient-to-b from-orange-950 to-orange-900 rounded-xl p-2 border-2 border-orange-800 mb-3">
                  <div className="text-amber-200 text-xs text-center mb-1 font-bold">SPEED: {speed}</div>
                  <div className="flex gap-1">
                    {['LOW', 'MEDIUM', 'HIGH'].map((s, i) => (
                      <button
                        key={s}
                        onClick={() => setSpeed(s)}
                        className={`flex-1 py-1 rounded-lg font-bold text-xs ${
                          speed === s ? 'opacity-100' : 'opacity-70'
                        } ${
                          i === 0 ? 'bg-green-600 text-white' :
                          i === 1 ? 'bg-orange-600 text-white' :
                          'bg-red-600 text-white'
                        }`}
                      >
                        {s}
                      </button>
                    ))}
                  </div>
                </div>
                
                <div className="bg-gradient-to-b from-orange-950 to-orange-900 rounded-xl p-3 border-2 border-orange-800 mb-3">
                  <div className="text-amber-200 text-xs text-center mb-2 font-bold">BET AMOUNT</div>
                  <div className="flex items-center justify-between gap-2">
                    <button 
                      onClick={() => setBetAmount(prev => Math.max(1, prev / 2))}
                      className="bg-orange-800 text-amber-200 px-2 py-1 rounded-lg text-xs font-bold"
                    >
                      ¬Ω
                    </button>
                    <div className="flex-1 bg-gradient-to-b from-orange-800 to-orange-900 rounded-lg py-2 border border-orange-700">
                      <div className="text-lg font-bold text-center text-amber-100">
                        ${betAmount.toFixed(2)}
                      </div>
                    </div>
                    <button 
                      onClick={() => setBetAmount(prev => Math.min(1000, prev * 2))}
                      className="bg-orange-800 text-amber-200 px-2 py-1 rounded-lg text-xs font-bold"
                    >
                      2√ó
                    </button>
                  </div>
                </div>
                
                <div className="flex gap-2">
                  <button
                    onClick={() => setShowInfo(!showInfo)}
                    className="bg-purple-700 text-white p-2 rounded-full shadow-lg"
                  >
                    <Info className="w-5 h-5" />
                  </button>
                  
                  <button
                    onClick={() => setGameState('paused')}
                    className="flex-1 bg-gradient-to-b from-cyan-400 to-cyan-600 text-white py-2 px-6 rounded-2xl font-bold shadow-xl border-2 border-cyan-300"
                  >
                    PAUSE
                  </button>
                  
                  <button
                    className={`p-2 rounded-full shadow-lg ${autoplay ? 'bg-green-600' : 'bg-orange-700'} text-white`}
                  >
                    <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                      <path d="M10 2a8 8 0 100 16 8 8 0 000-16zm0 14a6 6 0 110-12 6 6 0 010 12z"/>
                    </svg>
                  </button>
                </div>
              </div>
            </div>
            
            {/* Stats */}
            <div className="absolute top-4 left-4 bg-purple-900/80 rounded-xl p-3 border-2 border-purple-600 z-40">
              <div className="text-purple-200 text-xs space-y-1">
                <div className="font-bold">–ü—Ä–æ–π–¥–µ–Ω–æ: <span className="text-cyan-400">{Math.floor(traveledDistance).toLocaleString()} –∫–º</span></div>
                <div className="font-bold">–ë—É–ª—å–±–∞—à–∫–∏: <span className="text-white">{bubblesCollected}</span></div>
                <div className="font-bold">–í–∏–≥—Ä–∞—à: <span className="text-green-400">${totalWin.toFixed(2)}</span></div>
                <div className="font-bold">–ß–∞—Å: <span className="text-white">{flightTime}—Å</span></div>
              </div>
            </div>
          </>
        )}
        
        {/* Paused */}
        {gameState === 'paused' && (
          <div className="absolute inset-0 bg-black/70 flex items-center justify-center z-50">
            <div className="bg-gradient-to-br from-amber-900/95 to-orange-950/95 rounded-2xl p-6 border-4 border-amber-700 max-w-md w-full mx-4">
              <h2 className="text-3xl font-bold text-amber-200 text-center mb-6">–ü–ê–£–ó–ê</h2>
              
              <button
                onClick={() => setGameState('playing')}
                className="w-full bg-gradient-to-b from-cyan-400 to-cyan-600 text-white py-3 rounded-xl font-bold mb-3 shadow-xl"
              >
                –ü–†–û–î–û–í–ñ–ò–¢–ò
              </button>
              
              <button
                onClick={() => setGameState('menu')}
                className="w-full bg-gradient-to-b from-red-500 to-red-700 text-white py-3 rounded-xl font-bold shadow-xl"
              >
                –í–ò–ô–¢–ò
              </button>
            </div>
          </div>
        )}
        
        {/* Finished */}
        {gameState === 'finished' && (
          <div className="absolute inset-0 bg-black/80 flex items-center justify-center z-50">
            <div className="bg-gradient-to-br from-amber-900/95 to-orange-950/95 rounded-3xl p-8 border-4 border-amber-700 max-w-lg w-full mx-4">
              <div className="text-center mb-6">
                <div className="text-6xl mb-4">üåô‚ú®</div>
                <h2 className="text-4xl font-bold text-amber-200 mb-2">–¢–ò –î–û–õ–ï–¢–Ü–í –î–û –ú–Ü–°–Ø–¶–Ø!</h2>
                <p className="text-amber-300">–í—ñ—Ç–∞—î–º–æ, –∫–æ—Å–º–æ–Ω–∞–≤—Ç–µ! üéâ</p>
              </div>
              
              <div className="bg-orange-950/50 rounded-xl p-6 border-2 border-orange-800 mb-6">
                <h3 className="text-amber-200 font-bold mb-3 text-center">–°–¢–ê–¢–ò–°–¢–ò–ö–ê –ü–û–õ–¨–û–¢–£</h3>
                <div className="text-amber-300 space-y-2">
                  <div className="flex justify-between">
                    <span>–ü—Ä–æ–π–¥–µ–Ω–æ:</span>
                    <span className="font-bold text-cyan-400">{Math.floor(traveledDistance).toLocaleString()} –∫–º</span>
                  </div>
                  <div className="flex justify-between">
                    <span>–ß–∞—Å:</span>
                    <span className="font-bold text-white">{flightTime}—Å</span>
                  </div>
                  <div className="flex justify-between">
                    <span>–ë—É–ª—å–±–∞—à–∫–∏:</span>
                    <span className="font-bold text-white">{bubblesCollected}</span>
                  </div>
                  <div className="flex justify-between">
                    <span>–ó–∞–≥–∞–ª—å–Ω–∏–π –≤–∏–≥—Ä–∞—à:</span>
                    <span className="font-bold text-green-400">${totalWin.toFixed(2)}</span>
                  </div>
                </div>
              </div>
              
              <div className="flex gap-3">
                <button
                  onClick={startGame}
                  className="flex-1 bg-gradient-to-b from-cyan-400 to-cyan-600 text-white py-3 rounded-xl font-bold shadow-xl"
                >
                  –†–ï–°–¢–ê–†–¢
                </button>
                <button
                  className="flex-1 bg-gradient-to-b from-purple-500 to-purple-700 text-white py-3 rounded-xl font-bold shadow-xl flex items-center justify-center gap-2"
                >
                  üèÅ –ü–†–ê–ü–û–†
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default ToTheMoonGame;